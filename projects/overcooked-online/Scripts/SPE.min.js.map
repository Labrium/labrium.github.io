{"version":3,"sources":["./src/SPE.js"],"sourcesContent":["/* shader-particle-engine 1.0.6\n * \n * (c) 2015 Luke Moody (http://www.github.com/squarefeet)\n *     Originally based on Lee Stemkoski's original work (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).\n *\n * shader-particle-engine may be freely distributed under the MIT license (See LICENSE at root of this repository.)\n */\n/**\n * @typedef {Number} distribution\n * @property {Number} SPE.distributions.BOX Values will be distributed within a box.\n * @property {Number} SPE.distributions.SPHERE Values will be distributed within a sphere.\n * @property {Number} SPE.distributions.DISC Values will be distributed within a 2D disc.\n */\n\n/**\n * Namespace for Shader Particle Engine.\n *\n * All SPE-related code sits under this namespace.\n *\n * @type {Object}\n * @namespace\n */\nvar SPE = {\n\n\r/**\n\r * A map of supported distribution types used\n\r * by SPE.Emitter instances.\n\r *\n\r * These distribution types can be applied to\n\r * an emitter globally, which will affect the\n\r * `position`, `velocity`, and `acceleration`\n\r * value calculations for an emitter, or they\n\r * can be applied on a per-property basis.\n\r *\n\r * @enum {Number}\n\r */\n\rdistributions: {\n\r\r/**\n\r\r * Values will be distributed within a box.\n\r\r * @type {Number}\n\r\r */\n\r\rBOX: 1,\n\n\r\r/**\n\r\r * Values will be distributed on a sphere.\n\r\r * @type {Number}\n\r\r */\n\r\rSPHERE: 2,\n\n\r\r/**\n\r\r * Values will be distributed on a 2d-disc shape.\n\r\r * @type {Number}\n\r\r */\n\r\rDISC: 3,\n\n\r\r/**\n\r\r * Values will be distributed along a line.\n\r\r * @type {Number}\n\r\r */\n\r\rLINE: 4\n\r},\n\n\n\r/**\n\r * Set this value to however many 'steps' you\n\r * want value-over-lifetime properties to have.\n\r *\n\r * It's adjustable to fix an interpolation problem:\n\r *\n\r * Assuming you specify an opacity value as [0, 1, 0]\n\r *      and the `valueOverLifetimeLength` is 4, then the\n\r *      opacity value array will be reinterpolated to\n\r *      be [0, 0.66, 0.66, 0].\n\r *   This isn't ideal, as particles would never reach\n\r *   full opacity.\n\r *\n\r * NOTE:\n\r *     This property affects the length of ALL\n\r *       value-over-lifetime properties for ALL\n\r *       emitters and ALL groups.\n\r *\n\r *     Only values >= 3 && <= 4 are allowed.\n\r *\n\r * @type {Number}\n\r */\n\rvalueOverLifetimeLength: 4\n};\n\n// Module loader support:\nif (typeof define === 'function' && define.amd) {\n\rdefine('spe', SPE);\n}\nelse if (typeof exports !== 'undefined' && typeof module !== 'undefined') {\n\rmodule.exports = SPE;\n}\n\n\n/**\n * A helper class for TypedArrays.\n *\n * Allows for easy resizing, assignment of various component-based\n * types (Vector2s, Vector3s, Vector4s, Mat3s, Mat4s),\n * as well as Colors (where components are `r`, `g`, `b`),\n * Numbers, and setting from other TypedArrays.\n *\n * @author Luke Moody\n * @constructor\n * @param {Function} TypedArrayConstructor The constructor to use (Float32Array, Uint8Array, etc.)\n * @param {Number} size                 The size of the array to create\n * @param {Number} componentSize        The number of components per-value (ie. 3 for a vec3, 9 for a Mat3, etc.)\n * @param {Number} indexOffset          The index in the array from which to start assigning values. Default `0` if none provided\n */\nSPE.TypedArrayHelper = function (TypedArrayConstructor, size, componentSize, indexOffset) {\n\r'use strict';\n\n\rthis.componentSize = componentSize || 1;\n\rthis.size = (size || 1);\n\rthis.TypedArrayConstructor = TypedArrayConstructor || Float32Array;\n\rthis.array = new TypedArrayConstructor(size * this.componentSize);\n\rthis.indexOffset = indexOffset || 0;\n};\n\nSPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper;\n\n/**\n * Sets the size of the internal array.\n *\n * Delegates to `this.shrink` or `this.grow` depending on size\n * argument's relation to the current size of the internal array.\n *\n * Note that if the array is to be shrunk, data will be lost.\n *\n * @param {Number} size The new size of the array.\n */\nSPE.TypedArrayHelper.prototype.setSize = function (size, noComponentMultiply) {\n\r'use strict';\n\n\rvar currentArraySize = this.array.length;\n\n\rif (!noComponentMultiply) {\n\r\rsize = size * this.componentSize;\n\r}\n\n\rif (size < currentArraySize) {\n\r\rreturn this.shrink(size);\n\r}\n\relse if (size > currentArraySize) {\n\r\rreturn this.grow(size);\n\r}\n\relse {\n\r\rconsole.info('TypedArray is already of size:', size + '.', 'Will not resize.');\n\r}\n};\n\n/**\n * Shrinks the internal array.\n *\n * @param  {Number} size The new size of the typed array. Must be smaller than `this.array.length`.\n * @return {SPE.TypedArrayHelper}      Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.shrink = function (size) {\n\r'use strict';\n\n\rthis.array = this.array.subarray(0, size);\n\rthis.size = size;\n\rreturn this;\n};\n\n/**\n * Grows the internal array.\n * @param  {Number} size The new size of the typed array. Must be larger than `this.array.length`.\n * @return {SPE.TypedArrayHelper}      Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.grow = function (size) {\n\r'use strict';\n\n\rvar existingArray = this.array,\n\r\rnewArray = new this.TypedArrayConstructor(size);\n\n\rnewArray.set(existingArray);\n\rthis.array = newArray;\n\rthis.size = size;\n\n\rreturn this;\n};\n\n\n/**\n * Perform a splice operation on this array's buffer.\n * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.\n * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.\n * @returns {Object} The SPE.TypedArrayHelper instance.\n */\nSPE.TypedArrayHelper.prototype.splice = function (start, end) {\n\r'use strict';\n\rstart *= this.componentSize;\n\rend *= this.componentSize;\n\n\rvar data = [],\n\r\rarray = this.array,\n\r\rsize = array.length;\n\n\rfor (var i = 0; i < size; ++i) {\n\r\rif (i < start || i >= end) {\n\r\r\rdata.push(array[i]);\n\r\r}\n\r\r// array[ i ] = 0;\n\r}\n\n\rthis.setFromArray(0, data);\n\n\rreturn this;\n};\n\n\n/**\n * Copies from the given TypedArray into this one, using the index argument\n * as the start position. Alias for `TypedArray.set`. Will automatically resize\n * if the given source array is of a larger size than the internal array.\n *\n * @param {Number} index      The start position from which to copy into this array.\n * @param {TypedArray} array The array from which to copy; the source array.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setFromArray = function (index, array) {\n\r'use strict';\n\n\rvar sourceArraySize = array.length,\n\r\rnewSize = index + sourceArraySize;\n\n\rif (newSize > this.array.length) {\n\r\rthis.grow(newSize);\n\r}\n\relse if (newSize < this.array.length) {\n\r\rthis.shrink(newSize);\n\r}\n\n\rthis.array.set(array, this.indexOffset + index);\n\n\rreturn this;\n};\n\n/**\n * Set a Vector2 value at `index`.\n *\n * @param {Number} index The index at which to set the vec2 values from.\n * @param {Vector2} vec2  Any object that has `x` and `y` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec2 = function (index, vec2) {\n\r'use strict';\n\n\rreturn this.setVec2Components(index, vec2.x, vec2.y);\n};\n\n/**\n * Set a Vector2 value using raw components.\n *\n * @param {Number} index The index at which to set the vec2 values from.\n * @param {Number} x     The Vec2's `x` component.\n * @param {Number} y     The Vec2's `y` component.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec2Components = function (index, x, y) {\n\r'use strict';\n\n\rvar array = this.array,\n\r\ri = this.indexOffset + (index * this.componentSize);\n\n\rarray[i] = x;\n\rarray[i + 1] = y;\n\rreturn this;\n};\n\n/**\n * Set a Vector3 value at `index`.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Vector3} vec2  Any object that has `x`, `y`, and `z` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec3 = function (index, vec3) {\n\r'use strict';\n\n\rreturn this.setVec3Components(index, vec3.x, vec3.y, vec3.z);\n};\n\n/**\n * Set a Vector3 value using raw components.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Number} x     The Vec3's `x` component.\n * @param {Number} y     The Vec3's `y` component.\n * @param {Number} z     The Vec3's `z` component.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec3Components = function (index, x, y, z) {\n\r'use strict';\n\n\rvar array = this.array,\n\r\ri = this.indexOffset + (index * this.componentSize);\n\n\rarray[i] = x;\n\rarray[i + 1] = y;\n\rarray[i + 2] = z;\n\rreturn this;\n};\n\n/**\n * Set a Vector4 value at `index`.\n *\n * @param {Number} index The index at which to set the vec4 values from.\n * @param {Vector4} vec2  Any object that has `x`, `y`, `z`, and `w` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec4 = function (index, vec4) {\n\r'use strict';\n\n\rreturn this.setVec4Components(index, vec4.x, vec4.y, vec4.z, vec4.w);\n};\n\n/**\n * Set a Vector4 value using raw components.\n *\n * @param {Number} index The index at which to set the vec4 values from.\n * @param {Number} x     The Vec4's `x` component.\n * @param {Number} y     The Vec4's `y` component.\n * @param {Number} z     The Vec4's `z` component.\n * @param {Number} w     The Vec4's `w` component.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec4Components = function (index, x, y, z, w) {\n\r'use strict';\n\n\rvar array = this.array,\n\r\ri = this.indexOffset + (index * this.componentSize);\n\n\rarray[i] = x;\n\rarray[i + 1] = y;\n\rarray[i + 2] = z;\n\rarray[i + 3] = w;\n\rreturn this;\n};\n\n/**\n * Set a Matrix3 value at `index`.\n *\n * @param {Number} index The index at which to set the matrix values from.\n * @param {Matrix3} mat3 The 3x3 matrix to set from. Must have a TypedArray property named `elements` to copy from.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setMat3 = function (index, mat3) {\n\r'use strict';\n\n\rreturn this.setFromArray(this.indexOffset + (index * this.componentSize), mat3.elements);\n};\n\n/**\n * Set a Matrix4 value at `index`.\n *\n * @param {Number} index The index at which to set the matrix values from.\n * @param {Matrix4} mat3 The 4x4 matrix to set from. Must have a TypedArray property named `elements` to copy from.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setMat4 = function (index, mat4) {\n\r'use strict';\n\n\rreturn this.setFromArray(this.indexOffset + (index * this.componentSize), mat4.elements);\n};\n\n/**\n * Set a Color value at `index`.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Color} color  Any object that has `r`, `g`, and `b` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setColor = function (index, color) {\n\r'use strict';\n\n\rreturn this.setVec3Components(index, color.r, color.g, color.b);\n};\n\n/**\n * Set a Number value at `index`.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Number} numericValue  The number to assign to this index in the array.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setNumber = function (index, numericValue) {\n\r'use strict';\n\n\rthis.array[this.indexOffset + (index * this.componentSize)] = numericValue;\n\rreturn this;\n};\n\n/**\n * Returns the value of the array at the given index, taking into account\n * the `indexOffset` property of this class.\n *\n * Note that this function ignores the component size and will just return a\n * single value.\n *\n * @param  {Number} index The index in the array to fetch.\n * @return {Number}       The value at the given index.\n */\nSPE.TypedArrayHelper.prototype.getValueAtIndex = function (index) {\n\r'use strict';\n\n\rreturn this.array[this.indexOffset + index];\n};\n\n/**\n * Returns the component value of the array at the given index, taking into account\n * the `indexOffset` property of this class.\n *\n * If the componentSize is set to 3, then it will return a new TypedArray\n * of length 3.\n *\n * @param  {Number} index The index in the array to fetch.\n * @return {TypedArray}       The component value at the given index.\n */\nSPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function (index) {\n\r'use strict';\n\n\rreturn this.array.subarray(this.indexOffset + (index * this.componentSize));\n};\n\n/**\n * A helper to handle creating and updating a THREE.BufferAttribute instance.\n *\n * @author  Luke Moody\n * @constructor\n * @param {String} type          The buffer attribute type. See SPE.ShaderAttribute.typeSizeMap for valid values.\n * @param {Boolean=} dynamicBuffer Whether this buffer attribute should be marked as dynamic or not.\n * @param {Function=} arrayType     A reference to a TypedArray constructor. Defaults to Float32Array if none provided.\n */\nSPE.ShaderAttribute = function (type, dynamicBuffer, arrayType) {\n\r'use strict';\n\n\rvar typeMap = SPE.ShaderAttribute.typeSizeMap;\n\n\rthis.type = typeof type === 'string' && typeMap.hasOwnProperty(type) ? type : 'f';\n\rthis.componentSize = typeMap[this.type];\n\rthis.arrayType = arrayType || Float32Array;\n\rthis.typedArray = null;\n\rthis.bufferAttribute = null;\n\rthis.dynamicBuffer = !!dynamicBuffer;\n\n\rthis.updateMin = 0;\n\rthis.updateMax = 0;\n};\n\nSPE.ShaderAttribute.constructor = SPE.ShaderAttribute;\n\n/**\n * A map of uniform types to their component size.\n * @enum {Number}\n */\nSPE.ShaderAttribute.typeSizeMap = {\n\r/**\n\r * Float\n\r * @type {Number}\n\r */\n\rf: 1,\n\n\r/**\n\r * Vec2\n\r * @type {Number}\n\r */\n\rv2: 2,\n\n\r/**\n\r * Vec3\n\r * @type {Number}\n\r */\n\rv3: 3,\n\n\r/**\n\r * Vec4\n\r * @type {Number}\n\r */\n\rv4: 4,\n\n\r/**\n\r * Color\n\r * @type {Number}\n\r */\n\rc: 3,\n\n\r/**\n\r * Mat3\n\r * @type {Number}\n\r */\n\rm3: 9,\n\n\r/**\n\r * Mat4\n\r * @type {Number}\n\r */\n\rm4: 16\n};\n\n/**\n * Calculate the minimum and maximum update range for this buffer attribute using\n * component size independant min and max values.\n *\n * @param {Number} min The start of the range to mark as needing an update.\n * @param {Number} max The end of the range to mark as needing an update.\n */\nSPE.ShaderAttribute.prototype.setUpdateRange = function (min, max) {\n\r'use strict';\n\n\rthis.updateMin = Math.min(min * this.componentSize, this.updateMin * this.componentSize);\n\rthis.updateMax = Math.max(max * this.componentSize, this.updateMax * this.componentSize);\n};\n\n/**\n * Calculate the number of indices that this attribute should mark as needing\n * updating. Also marks the attribute as needing an update.\n */\nSPE.ShaderAttribute.prototype.flagUpdate = function () {\n\r'use strict';\n\n\rvar attr = this.bufferAttribute,\n\r\rrange = attr.updateRange;\n\n\rrange.offset = this.updateMin;\n\rrange.count = Math.min((this.updateMax - this.updateMin) + this.componentSize, this.typedArray.array.length);\n\r// console.log( range.offset, range.count, this.typedArray.array.length );\n\r// console.log( 'flagUpdate:', range.offset, range.count );\n\rattr.needsUpdate = true;\n};\n\n\n\n/**\n * Reset the index update counts for this attribute\n */\nSPE.ShaderAttribute.prototype.resetUpdateRange = function () {\n\r'use strict';\n\n\rthis.updateMin = 0;\n\rthis.updateMax = 0;\n};\n\nSPE.ShaderAttribute.prototype.resetDynamic = function () {\n\r'use strict';\n\rthis.bufferAttribute.usage = this.dynamicBuffer ?\n\r\rTHREE.DynamicDrawUsage :\n\r\rTHREE.StaticDrawUsage;\n};\n\n/**\n * Perform a splice operation on this attribute's buffer.\n * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.\n * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.\n */\nSPE.ShaderAttribute.prototype.splice = function (start, end) {\n\r'use strict';\n\n\rthis.typedArray.splice(start, end);\n\n\r// Reset the reference to the attribute's typed array\n\r// since it has probably changed.\n\rthis.forceUpdateAll();\n};\n\nSPE.ShaderAttribute.prototype.forceUpdateAll = function () {\n\r'use strict';\n\n\rthis.bufferAttribute.array = this.typedArray.array;\n\rthis.bufferAttribute.updateRange.offset = 0;\n\rthis.bufferAttribute.updateRange.count = -1;\n\r// this.bufferAttribute.dynamic = false;\n\r// this.bufferAttribute.usage = this.dynamicBuffer ?\n\r// \rTHREE.DynamicDrawUsage :\n\r// \rTHREE.StaticDrawUsage;\n\n\rthis.bufferAttribute.usage = THREE.StaticDrawUsage;\n\rthis.bufferAttribute.needsUpdate = true;\n};\n\n/**\n * Make sure this attribute has a typed array associated with it.\n *\n * If it does, then it will ensure the typed array is of the correct size.\n *\n * If not, a new SPE.TypedArrayHelper instance will be created.\n *\n * @param  {Number} size The size of the typed array to create or update to.\n */\nSPE.ShaderAttribute.prototype._ensureTypedArray = function (size) {\n\r'use strict';\n\n\r// Condition that's most likely to be true at the top: no change.\n\rif (this.typedArray !== null && this.typedArray.size === size * this.componentSize) {\n\r\rreturn;\n\r}\n\n\r// Resize the array if we need to, telling the TypedArrayHelper to\n\r// ignore it's component size when evaluating size.\n\relse if (this.typedArray !== null && this.typedArray.size !== size) {\n\r\rthis.typedArray.setSize(size);\n\r}\n\n\r// This condition should only occur once in an attribute's lifecycle.\n\relse if (this.typedArray === null) {\n\r\rthis.typedArray = new SPE.TypedArrayHelper(this.arrayType, size, this.componentSize);\n\r}\n};\n\n\n/**\n * Creates a THREE.BufferAttribute instance if one doesn't exist already.\n *\n * Ensures a typed array is present by calling _ensureTypedArray() first.\n *\n * If a buffer attribute exists already, then it will be marked as needing an update.\n *\n * @param  {Number} size The size of the typed array to create if one doesn't exist, or resize existing array to.\n */\nSPE.ShaderAttribute.prototype._createBufferAttribute = function (size) {\n\r'use strict';\n\n\r// Make sure the typedArray is present and correct.\n\rthis._ensureTypedArray(size);\n\n\r// Don't create it if it already exists, but do\n\r// flag that it needs updating on the next render\n\r// cycle.\n\rif (this.bufferAttribute !== null) {\n\r\rthis.bufferAttribute.array = this.typedArray.array;\n\n\r\r// Since THREE.js version 81, dynamic count calculation was removed\n\r\r// so I need to do it manually here.\n\r\r//\n\r\r// In the next minor release, I may well remove this check and force\n\r\r// dependency on THREE r81+.\n\r\rif (parseFloat(THREE.REVISION) >= 81) {\n\r\r\rthis.bufferAttribute.count = this.bufferAttribute.array.length / this.bufferAttribute.itemSize;\n\r\r}\n\n\r\rthis.bufferAttribute.needsUpdate = true;\n\r\rreturn;\n\r}\n\n\rthis.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize);\n\r// this.bufferAttribute.dynamic = this.dynamicBuffer;\n\rthis.bufferAttribute.usage = this.dynamicBuffer ?\n\r\rTHREE.DynamicDrawUsage :\n\r\rTHREE.StaticDrawUsage;\n};\n\n/**\n * Returns the length of the typed array associated with this attribute.\n * @return {Number} The length of the typed array. Will be 0 if no typed array has been created yet.\n */\nSPE.ShaderAttribute.prototype.getLength = function () {\n\r'use strict';\n\n\rif (this.typedArray === null) {\n\r\rreturn 0;\n\r}\n\n\rreturn this.typedArray.array.length;\n};\n\n\nSPE.shaderChunks = {\n\r// Register color-packing define statements.\n\rdefines: [\n\r\r'#define PACKED_COLOR_SIZE 256.0',\n\r\r'#define PACKED_COLOR_DIVISOR 255.0'\n\r].join('\n'),\n\n\r// All uniforms used by vertex / fragment shaders\n\runiforms: [\n\r\r'uniform float deltaTime;',\n\r\r'uniform float runTime;',\n\r\r'uniform sampler2D tex;',\n\r\r'uniform vec4 textureAnimation;',\n\r\r'uniform float scale;',\n\r].join('\n'),\n\n\r// All attributes used by the vertex shader.\n\r//\n\r// Note that some attributes are squashed into other ones:\n\r//\n\r// * Drag is acceleration.w\n\rattributes: [\n\r\r'attribute vec4 acceleration;',\n\r\r'attribute vec3 velocity;',\n\r\r'attribute vec4 rotation;',\n\r\r'attribute vec3 rotationCenter;',\n\r\r'attribute vec4 params;',\n\r\r'attribute vec4 size;',\n\r\r'attribute vec4 angle;',\n\r\r'attribute vec4 color;',\n\r\r'attribute vec4 opacity;'\n\r].join('\n'),\n\n\r//\n\rvaryings: [\n\r\r'varying vec4 vColor;',\n\r\r'#ifdef SHOULD_ROTATE_TEXTURE',\n\r\r'    varying float vAngle;',\n\r\r'#endif',\n\n\r\r'#ifdef SHOULD_CALCULATE_SPRITE',\n\r\r'    varying vec4 vSpriteSheet;',\n\r\r'#endif'\n\r].join('\n'),\n\n\n\r// Branch-avoiding comparison fns\n\r// - http://theorangeduck.com/page/avoiding-shader-conditionals\n\rbranchAvoidanceFunctions: [\n\r\r'float when_gt(float x, float y) {',\n\r\r'    return max(sign(x - y), 0.0);',\n\r\r'}',\n\n\r\r'float when_lt(float x, float y) {',\n\r\r'    return min( max(1.0 - sign(x - y), 0.0), 1.0 );',\n\r\r'}',\n\n\r\r'float when_eq( float x, float y ) {',\n\r\r'    return 1.0 - abs( sign( x - y ) );',\n\r\r'}',\n\n\r\r'float when_ge(float x, float y) {',\n\r\r'  return 1.0 - when_lt(x, y);',\n\r\r'}',\n\n\r\r'float when_le(float x, float y) {',\n\r\r'  return 1.0 - when_gt(x, y);',\n\r\r'}',\n\n\r\r// Branch-avoiding logical operators\n\r\r// (to be used with above comparison fns)\n\r\r'float and(float a, float b) {',\n\r\r'    return a * b;',\n\r\r'}',\n\n\r\r'float or(float a, float b) {',\n\r\r'    return min(a + b, 1.0);',\n\r\r'}',\n\r].join('\n'),\n\n\n\r// From:\n\r// - http://stackoverflow.com/a/12553149\n\r// - https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader\n\runpackColor: [\n\r\r'vec3 unpackColor( in float hex ) {',\n\r\r'   vec3 c = vec3( 0.0 );',\n\n\r\r'   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n\r\r'   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n\r\r'   float b = mod( hex, PACKED_COLOR_SIZE );',\n\n\r\r'   c.r = r / PACKED_COLOR_DIVISOR;',\n\r\r'   c.g = g / PACKED_COLOR_DIVISOR;',\n\r\r'   c.b = b / PACKED_COLOR_DIVISOR;',\n\n\r\r'   return c;',\n\r\r'}',\n\r].join('\n'),\n\n\runpackRotationAxis: [\n\r\r'vec3 unpackRotationAxis( in float hex ) {',\n\r\r'   vec3 c = vec3( 0.0 );',\n\n\r\r'   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n\r\r'   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n\r\r'   float b = mod( hex, PACKED_COLOR_SIZE );',\n\n\r\r'   c.r = r / PACKED_COLOR_DIVISOR;',\n\r\r'   c.g = g / PACKED_COLOR_DIVISOR;',\n\r\r'   c.b = b / PACKED_COLOR_DIVISOR;',\n\n\r\r'   c *= vec3( 2.0 );',\n\r\r'   c -= vec3( 1.0 );',\n\n\r\r'   return c;',\n\r\r'}',\n\r].join('\n'),\n\n\rfloatOverLifetime: [\n\r\r'float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {',\n\r\r'    highp float value = 0.0;',\n\r\r'    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );',\n\r\r'    float fIndex = 0.0;',\n\r\r'    float shouldApplyValue = 0.0;',\n\n\r\r// This might look a little odd, but it's faster in the testing I've done than using branches.\n\r\r// Uses basic maths to avoid branching.\n\r\r//\n\r\r// Take a look at the branch-avoidance functions defined above,\n\r\r// and be sure to check out The Orange Duck site where I got this\n\r\r// from (link above).\n\n\r\r// Fix for static emitters (age is always zero).\n\r\r'    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );',\n\r\r'',\n\r\r'    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {',\n\r\r'       fIndex = float( i );',\n\r\r'       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );',\n\r\r'       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );',\n\r\r'    }',\n\r\r'',\n\r\r'    return value;',\n\r\r'}',\n\r].join('\n'),\n\n\rcolorOverLifetime: [\n\r\r'vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {',\n\r\r'    vec3 value = vec3( 0.0 );',\n\r\r'    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );',\n\r\r'    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );',\n\r\r'    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );',\n\r\r'    return value;',\n\r\r'}',\n\r].join('\n'),\n\n\rparamFetchingFunctions: [\n\r\r'float getAlive() {',\n\r\r'   return params.x;',\n\r\r'}',\n\n\r\r'float getAge() {',\n\r\r'   return params.y;',\n\r\r'}',\n\n\r\r'float getMaxAge() {',\n\r\r'   return params.z;',\n\r\r'}',\n\n\r\r'float getWiggle() {',\n\r\r'   return params.w;',\n\r\r'}',\n\r].join('\n'),\n\n\rforceFetchingFunctions: [\n\r\r'vec4 getPosition( in float age ) {',\n\r\r'   return modelViewMatrix * vec4( position, 1.0 );',\n\r\r'}',\n\n\r\r'vec3 getVelocity( in float age ) {',\n\r\r'   return velocity * age;',\n\r\r'}',\n\n\r\r'vec3 getAcceleration( in float age ) {',\n\r\r'   return acceleration.xyz * age;',\n\r\r'}',\n\r].join('\n'),\n\n\n\rrotationFunctions: [\n\r\r// Huge thanks to:\n\r\r// - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n\r\r'#ifdef SHOULD_ROTATE_PARTICLES',\n\r\r'   mat4 getRotationMatrix( in vec3 axis, in float angle) {',\n\r\r'       axis = normalize(axis);',\n\r\r'       float s = sin(angle);',\n\r\r'       float c = cos(angle);',\n\r\r'       float oc = 1.0 - c;',\n\r\r'',\n\r\r'       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,',\n\r\r'                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,',\n\r\r'                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,',\n\r\r'                   0.0,                                0.0,                                0.0,                                1.0);',\n\r\r'   }',\n\r\r'',\n\r\r'   vec3 getRotation( in vec3 pos, in float positionInTime ) {',\n\r\r'      if( rotation.y == 0.0 ) {',\n\r\r'           return pos;',\n\r\r'      }',\n\r\r'',\n\r\r'      vec3 axis = unpackRotationAxis( rotation.x );',\n\r\r'      vec3 center = rotationCenter;',\n\r\r'      vec3 translated;',\n\r\r'      mat4 rotationMatrix;',\n\n\r\r'      float angle = 0.0;',\n\r\r'      angle += when_eq( rotation.z, 0.0 ) * rotation.y;',\n\r\r'      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );',\n\r\r'      translated = rotationCenter - pos;',\n\r\r'      rotationMatrix = getRotationMatrix( axis, angle );',\n\r\r'      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );',\n\r\r'   }',\n\r\r'#endif'\n\r].join('\n'),\n\n\n\r// Fragment chunks\n\rrotateTexture: [\n\r\r'    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );',\n\r\r'',\n\r\r'    #ifdef SHOULD_ROTATE_TEXTURE',\n\r\r'       float x = gl_PointCoord.x - 0.5;',\n\r\r'       float y = 1.0 - gl_PointCoord.y - 0.5;',\n\r\r'       float c = cos( -vAngle );',\n\r\r'       float s = sin( -vAngle );',\n\n\r\r'       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );',\n\r\r'    #endif',\n\r\r'',\n\n\r\r// Spritesheets overwrite angle calculations.\n\r\r'    #ifdef SHOULD_CALCULATE_SPRITE',\n\r\r'        float framesX = vSpriteSheet.x;',\n\r\r'        float framesY = vSpriteSheet.y;',\n\r\r'        float columnNorm = vSpriteSheet.z;',\n\r\r'        float rowNorm = vSpriteSheet.w;',\n\n\r\r'        vUv.x = gl_PointCoord.x * framesX + columnNorm;',\n\r\r'        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);',\n\r\r'    #endif',\n\n\r\r'',\n\r\r'    vec4 rotatedTexture = texture2D( tex, vUv );',\n\r].join('\n')\n};\n\nSPE.shaders = {\n\rvertex: [\n\r\rSPE.shaderChunks.defines,\n\r\rSPE.shaderChunks.uniforms,\n\r\rSPE.shaderChunks.attributes,\n\r\rSPE.shaderChunks.varyings,\n\n\r\rTHREE.ShaderChunk.common,\n\r\rTHREE.ShaderChunk.logdepthbuf_pars_vertex,\n\r\rTHREE.ShaderChunk.fog_pars_vertex,\n\n\r\rSPE.shaderChunks.branchAvoidanceFunctions,\n\r\rSPE.shaderChunks.unpackColor,\n\r\rSPE.shaderChunks.unpackRotationAxis,\n\r\rSPE.shaderChunks.floatOverLifetime,\n\r\rSPE.shaderChunks.colorOverLifetime,\n\r\rSPE.shaderChunks.paramFetchingFunctions,\n\r\rSPE.shaderChunks.forceFetchingFunctions,\n\r\rSPE.shaderChunks.rotationFunctions,\n\n\n\r\r'void main() {',\n\n\n\r\r//\n\r\r// Setup...\n\r\r//\n\r\r'    highp float age = getAge();',\n\r\r'    highp float alive = getAlive();',\n\r\r'    highp float maxAge = getMaxAge();',\n\r\r'    highp float positionInTime = (age / maxAge);',\n\r\r'    highp float isAlive = when_gt( alive, 0.0 );',\n\n\r\r'    #ifdef SHOULD_WIGGLE_PARTICLES',\n\r\r'        float wiggleAmount = positionInTime * getWiggle();',\n\r\r'        float wiggleSin = isAlive * sin( wiggleAmount );',\n\r\r'        float wiggleCos = isAlive * cos( wiggleAmount );',\n\r\r'    #endif',\n\n\r\r//\n\r\r// Forces\n\r\r//\n\n\r\r// Get forces & position\n\r\r'    vec3 vel = getVelocity( age );',\n\r\r'    vec3 accel = getAcceleration( age );',\n\r\r'    vec3 force = vec3( 0.0 );',\n\r\r'    vec3 pos = vec3( position );',\n\n\r\r// Calculate the required drag to apply to the forces.\n\r\r'    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;',\n\n\r\r// Integrate forces...\n\r\r'    force += vel;',\n\r\r'    force *= drag;',\n\r\r'    force += accel * age;',\n\r\r'    pos += force;',\n\n\n\r\r// Wiggly wiggly wiggle!\n\r\r'    #ifdef SHOULD_WIGGLE_PARTICLES',\n\r\r'        pos.x += wiggleSin;',\n\r\r'        pos.y += wiggleCos;',\n\r\r'        pos.z += wiggleSin;',\n\r\r'    #endif',\n\n\n\r\r// Rotate the emitter around it's central point\n\r\r'    #ifdef SHOULD_ROTATE_PARTICLES',\n\r\r'        pos = getRotation( pos, positionInTime );',\n\r\r'    #endif',\n\n\r\r// Convert pos to a world-space value\n\r\r'    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );',\n\n\r\r// Determine point size.\n\r\r'    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;',\n\n\r\r// Determine perspective\n\r\r'    #ifdef HAS_PERSPECTIVE',\n\r\r'        float perspective = scale / length( mvPosition.xyz );',\n\r\r'    #else',\n\r\r'        float perspective = 1.0;',\n\r\r'    #endif',\n\n\r\r// Apply perpective to pointSize value\n\r\r'    float pointSizePerspective = pointSize * perspective;',\n\n\n\r\r//\n\r\r// Appearance\n\r\r//\n\n\r\r// Determine color and opacity for this particle\n\r\r'    #ifdef COLORIZE',\n\r\r'       vec3 c = isAlive * getColorOverLifetime(',\n\r\r'           positionInTime,',\n\r\r'           unpackColor( color.x ),',\n\r\r'           unpackColor( color.y ),',\n\r\r'           unpackColor( color.z ),',\n\r\r'           unpackColor( color.w )',\n\r\r'       );',\n\r\r'    #else',\n\r\r'       vec3 c = vec3(1.0);',\n\r\r'    #endif',\n\n\r\r'    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );',\n\n\r\r// Assign color to vColor varying.\n\r\r'    vColor = vec4( c, o );',\n\n\r\r// Determine angle\n\r\r'    #ifdef SHOULD_ROTATE_TEXTURE',\n\r\r'        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );',\n\r\r'    #endif',\n\n\r\r// If this particle is using a sprite-sheet as a texture, we'll have to figure out\n\r\r// what frame of the texture the particle is using at it's current position in time.\n\r\r'    #ifdef SHOULD_CALCULATE_SPRITE',\n\r\r'        float framesX = textureAnimation.x;',\n\r\r'        float framesY = textureAnimation.y;',\n\r\r'        float loopCount = textureAnimation.w;',\n\r\r'        float totalFrames = textureAnimation.z;',\n\r\r'        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );',\n\n\r\r'        float column = floor(mod( frameNumber, framesX ));',\n\r\r'        float row = floor( (frameNumber - column) / framesX );',\n\n\r\r'        float columnNorm = column / framesX;',\n\r\r'        float rowNorm = row / framesY;',\n\n\r\r'        vSpriteSheet.x = 1.0 / framesX;',\n\r\r'        vSpriteSheet.y = 1.0 / framesY;',\n\r\r'        vSpriteSheet.z = columnNorm;',\n\r\r'        vSpriteSheet.w = rowNorm;',\n\r\r'    #endif',\n\n\r\r//\n\r\r// Write values\n\r\r//\n\n\r\r// Set PointSize according to size at current point in time.\n\r\r'    gl_PointSize = pointSizePerspective;',\n\r\r'    gl_Position = projectionMatrix * mvPosition;',\n\n\r\rTHREE.ShaderChunk.logdepthbuf_vertex,\n\r\rTHREE.ShaderChunk.fog_vertex,\n\n\r\r'}'\n\r].join('\n'),\n\n\rfragment: [\n\r\rSPE.shaderChunks.uniforms,\n\n\r\rTHREE.ShaderChunk.common,\n\r\rTHREE.ShaderChunk.fog_pars_fragment,\n\r\rTHREE.ShaderChunk.logdepthbuf_pars_fragment,\n\n\r\rSPE.shaderChunks.varyings,\n\n\r\rSPE.shaderChunks.branchAvoidanceFunctions,\n\n\r\r'void main() {',\n\r\r'    vec3 outgoingLight = vColor.xyz;',\n\r\r'    ',\n\r\r'    #ifdef ALPHATEST',\n\r\r'       if ( vColor.w < float(ALPHATEST) ) discard;',\n\r\r'    #endif',\n\n\r\rSPE.shaderChunks.rotateTexture,\n\n\r\rTHREE.ShaderChunk.logdepthbuf_fragment,\n\n\r\r'    outgoingLight = vColor.xyz * rotatedTexture.xyz;',\n\r\r'    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );',\n\n\r\rTHREE.ShaderChunk.fog_fragment,\n\n\r\r'}'\n\r].join('\n')\n};\n\n\n/**\n * A bunch of utility functions used throughout the library.\n * @namespace\n * @type {Object}\n */\nSPE.utils = {\n\r/**\n\r * A map of types used by `SPE.utils.ensureTypedArg` and\n\r * `SPE.utils.ensureArrayTypedArg` to compare types against.\n\r *\n\r * @enum {String}\n\r */\n\rtypes: {\n\r\r/**\n\r\r * Boolean type.\n\r\r * @type {String}\n\r\r */\n\r\rBOOLEAN: 'boolean',\n\n\r\r/**\n\r\r * String type.\n\r\r * @type {String}\n\r\r */\n\r\rSTRING: 'string',\n\n\r\r/**\n\r\r * Number type.\n\r\r * @type {String}\n\r\r */\n\r\rNUMBER: 'number',\n\n\r\r/**\n\r\r * Object type.\n\r\r * @type {String}\n\r\r */\n\r\rOBJECT: 'object'\n\r},\n\n\r/**\n\r * Given a value, a type, and a default value to fallback to,\n\r * ensure the given argument adheres to the type requesting,\n\r * returning the default value if type check is false.\n\r *\n\r * @param  {(boolean|string|number|object)} arg          The value to perform a type-check on.\n\r * @param  {String} type         The type the `arg` argument should adhere to.\n\r * @param  {(boolean|string|number|object)} defaultValue A default value to fallback on if the type check fails.\n\r * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.\n\r */\n\rensureTypedArg: function (arg, type, defaultValue) {\n\r\r'use strict';\n\n\r\rif (typeof arg === type) {\n\r\r\rreturn arg;\n\r\r}\n\r\relse {\n\r\r\rreturn defaultValue;\n\r\r}\n\r},\n\n\r/**\n\r * Given an array of values, a type, and a default value,\n\r * ensure the given array's contents ALL adhere to the provided type,\n\r * returning the default value if type check fails.\n\r *\n\r * If the given value to check isn't an Array, delegates to SPE.utils.ensureTypedArg.\n\r *\n\r * @param  {Array|boolean|string|number|object} arg          The array of values to check type of.\n\r * @param  {String} type         The type that should be adhered to.\n\r * @param  {(boolean|string|number|object)} defaultValue A default fallback value.\n\r * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.\n\r */\n\rensureArrayTypedArg: function (arg, type, defaultValue) {\n\r\r'use strict';\n\n\r\r// If the argument being checked is an array, loop through\n\r\r// it and ensure all the values are of the correct type,\n\r\r// falling back to the defaultValue if any aren't.\n\r\rif (Array.isArray(arg)) {\n\r\r\rfor (var i = arg.length - 1; i >= 0; --i) {\n\r\r\r\rif (typeof arg[i] !== type) {\n\r\r\r\r\rreturn defaultValue;\n\r\r\r\r}\n\r\r\r}\n\n\r\r\rreturn arg;\n\r\r}\n\n\r\r// If the arg isn't an array then just fallback to\n\r\r// checking the type.\n\r\rreturn this.ensureTypedArg(arg, type, defaultValue);\n\r},\n\n\r/**\n\r * Ensures the given value is an instance of a constructor function.\n\r *\n\r * @param  {Object} arg          The value to check instance of.\n\r * @param  {Function} instance     The constructor of the instance to check against.\n\r * @param  {Object} defaultValue A default fallback value if instance check fails\n\r * @return {Object}              The given value if type check passes, or the default value if it fails.\n\r */\n\rensureInstanceOf: function (arg, instance, defaultValue) {\n\r\r'use strict';\n\n\r\rif (instance !== undefined && arg instanceof instance) {\n\r\r\rreturn arg;\n\r\r}\n\r\relse {\n\r\r\rreturn defaultValue;\n\r\r}\n\r},\n\n\r/**\n\r * Given an array of values, ensure the instances of all items in the array\n\r * matches the given instance constructor falling back to a default value if\n\r * the check fails.\n\r *\n\r * If given value isn't an Array, delegates to `SPE.utils.ensureInstanceOf`.\n\r *\n\r * @param  {Array|Object} arg          The value to perform the instanceof check on.\n\r * @param  {Function} instance     The constructor of the instance to check against.\n\r * @param  {Object} defaultValue A default fallback value if instance check fails\n\r * @return {Object}              The given value if type check passes, or the default value if it fails.\n\r */\n\rensureArrayInstanceOf: function (arg, instance, defaultValue) {\n\r\r'use strict';\n\n\r\r// If the argument being checked is an array, loop through\n\r\r// it and ensure all the values are of the correct type,\n\r\r// falling back to the defaultValue if any aren't.\n\r\rif (Array.isArray(arg)) {\n\r\r\rfor (var i = arg.length - 1; i >= 0; --i) {\n\r\r\r\rif (instance !== undefined && arg[i] instanceof instance === false) {\n\r\r\r\r\rreturn defaultValue;\n\r\r\r\r}\n\r\r\r}\n\n\r\r\rreturn arg;\n\r\r}\n\n\r\r// If the arg isn't an array then just fallback to\n\r\r// checking the type.\n\r\rreturn this.ensureInstanceOf(arg, instance, defaultValue);\n\r},\n\n\r/**\n\r * Ensures that any 'value-over-lifetime' properties of an emitter are\n\r * of the correct length (as dictated by `SPE.valueOverLifetimeLength`).\n\r *\n\r * Delegates to `SPE.utils.interpolateArray` for array resizing.\n\r *\n\r * If properties aren't arrays, then property values are put into one.\n\r *\n\r * @param  {Object} property  The property of an SPE.Emitter instance to check compliance of.\n\r * @param  {Number} minLength The minimum length of the array to create.\n\r * @param  {Number} maxLength The maximum length of the array to create.\n\r */\n\rensureValueOverLifetimeCompliance: function (property, minLength, maxLength) {\n\r\r'use strict';\n\n\r\rminLength = minLength || 3;\n\r\rmaxLength = maxLength || 3;\n\n\r\r// First, ensure both properties are arrays.\n\r\rif (Array.isArray(property._value) === false) {\n\r\r\rproperty._value = [property._value];\n\r\r}\n\n\r\rif (Array.isArray(property._spread) === false) {\n\r\r\rproperty._spread = [property._spread];\n\r\r}\n\n\r\rvar valueLength = this.clamp(property._value.length, minLength, maxLength),\n\r\r\rspreadLength = this.clamp(property._spread.length, minLength, maxLength),\n\r\r\rdesiredLength = Math.max(valueLength, spreadLength);\n\n\r\rif (property._value.length !== desiredLength) {\n\r\r\rproperty._value = this.interpolateArray(property._value, desiredLength);\n\r\r}\n\n\r\rif (property._spread.length !== desiredLength) {\n\r\r\rproperty._spread = this.interpolateArray(property._spread, desiredLength);\n\r\r}\n\r},\n\n\r/**\n\r * Performs linear interpolation (lerp) on an array.\n\r *\n\r * For example, lerping [1, 10], with a `newLength` of 10 will produce [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n\r *\n\r * Delegates to `SPE.utils.lerpTypeAgnostic` to perform the actual\n\r * interpolation.\n\r *\n\r * @param  {Array} srcArray  The array to lerp.\n\r * @param  {Number} newLength The length the array should be interpolated to.\n\r * @return {Array}           The interpolated array.\n\r */\n\rinterpolateArray: function (srcArray, newLength) {\n\r\r'use strict';\n\n\r\rvar sourceLength = srcArray.length,\n\r\r\rnewArray = [typeof srcArray[0].clone === 'function' ? srcArray[0].clone() : srcArray[0]],\n\r\r\rfactor = (sourceLength - 1) / (newLength - 1);\n\n\n\r\rfor (var i = 1; i < newLength - 1; ++i) {\n\r\r\rvar f = i * factor,\n\r\r\r\rbefore = Math.floor(f),\n\r\r\r\rafter = Math.ceil(f),\n\r\r\r\rdelta = f - before;\n\n\r\r\rnewArray[i] = this.lerpTypeAgnostic(srcArray[before], srcArray[after], delta);\n\r\r}\n\n\r\rnewArray.push(\n\r\r\rtypeof srcArray[sourceLength - 1].clone === 'function' ?\n\r\r\r\rsrcArray[sourceLength - 1].clone() :\n\r\r\r\rsrcArray[sourceLength - 1]\n\r\r);\n\n\r\rreturn newArray;\n\r},\n\n\r/**\n\r * Clamp a number to between the given min and max values.\n\r * @param  {Number} value The number to clamp.\n\r * @param  {Number} min   The minimum value.\n\r * @param  {Number} max   The maximum value.\n\r * @return {Number}       The clamped number.\n\r */\n\rclamp: function (value, min, max) {\n\r\r'use strict';\n\n\r\rreturn Math.max(min, Math.min(value, max));\n\r},\n\n\r/**\n\r * If the given value is less than the epsilon value, then return\n\r * a randomised epsilon value if specified, or just the epsilon value if not.\n\r * Works for negative numbers as well as positive.\n\r *\n\r * @param  {Number} value     The value to perform the operation on.\n\r * @param  {Boolean} randomise Whether the value should be randomised.\n\r * @return {Number}           The result of the operation.\n\r */\n\rzeroToEpsilon: function (value, randomise) {\n\r\r'use strict';\n\n\r\rvar epsilon = 0.00001,\n\r\r\rresult = value;\n\n\r\rresult = randomise ? Math.random() * epsilon * 10 : epsilon;\n\n\r\rif (value < 0 && value > -epsilon) {\n\r\r\rresult = -result;\n\r\r}\n\n\r\r// if ( value === 0 ) {\n\r\r//     result = randomise ? Math.random() * epsilon * 10 : epsilon;\n\r\r// }\n\r\r// else if ( value > 0 && value < epsilon ) {\n\r\r//     result = randomise ? Math.random() * epsilon * 10 : epsilon;\n\r\r// }\n\r\r// else if ( value < 0 && value > -epsilon ) {\n\r\r//     result = -( randomise ? Math.random() * epsilon * 10 : epsilon );\n\r\r// }\n\n\r\rreturn result;\n\r},\n\n\r/**\n\r * Linearly interpolates two values of various types. The given values\n\r * must be of the same type for the interpolation to work.\n\r * @param  {(number|Object)} start The start value of the lerp.\n\r * @param  {(number|object)} end   The end value of the lerp.\n\r * @param  {Number} delta The delta posiiton of the lerp operation. Ideally between 0 and 1 (inclusive).\n\r * @return {(number|object|undefined)}       The result of the operation. Result will be undefined if\n\r *                                               the start and end arguments aren't a supported type, or\n\r *                                               if their types do not match.\n\r */\n\rlerpTypeAgnostic: function (start, end, delta) {\n\r\r'use strict';\n\n\r\rvar types = this.types,\n\r\r\rout;\n\n\r\rif (typeof start === types.NUMBER && typeof end === types.NUMBER) {\n\r\r\rreturn start + ((end - start) * delta);\n\r\r}\n\r\relse if (start instanceof THREE.Vector2 && end instanceof THREE.Vector2) {\n\r\r\rout = start.clone();\n\r\r\rout.x = this.lerp(start.x, end.x, delta);\n\r\r\rout.y = this.lerp(start.y, end.y, delta);\n\r\r\rreturn out;\n\r\r}\n\r\relse if (start instanceof THREE.Vector3 && end instanceof THREE.Vector3) {\n\r\r\rout = start.clone();\n\r\r\rout.x = this.lerp(start.x, end.x, delta);\n\r\r\rout.y = this.lerp(start.y, end.y, delta);\n\r\r\rout.z = this.lerp(start.z, end.z, delta);\n\r\r\rreturn out;\n\r\r}\n\r\relse if (start instanceof THREE.Vector4 && end instanceof THREE.Vector4) {\n\r\r\rout = start.clone();\n\r\r\rout.x = this.lerp(start.x, end.x, delta);\n\r\r\rout.y = this.lerp(start.y, end.y, delta);\n\r\r\rout.z = this.lerp(start.z, end.z, delta);\n\r\r\rout.w = this.lerp(start.w, end.w, delta);\n\r\r\rreturn out;\n\r\r}\n\r\relse if (start instanceof THREE.Color && end instanceof THREE.Color) {\n\r\r\rout = start.clone();\n\r\r\rout.r = this.lerp(start.r, end.r, delta);\n\r\r\rout.g = this.lerp(start.g, end.g, delta);\n\r\r\rout.b = this.lerp(start.b, end.b, delta);\n\r\r\rreturn out;\n\r\r}\n\r\relse {\n\r\r\rconsole.warn('Invalid argument types, or argument types do not match:', start, end);\n\r\r}\n\r},\n\n\r/**\n\r * Perform a linear interpolation operation on two numbers.\n\r * @param  {Number} start The start value.\n\r * @param  {Number} end   The end value.\n\r * @param  {Number} delta The position to interpolate to.\n\r * @return {Number}       The result of the lerp operation.\n\r */\n\rlerp: function (start, end, delta) {\n\r\r'use strict';\n\r\rreturn start + ((end - start) * delta);\n\r},\n\n\r/**\n\r * Rounds a number to a nearest multiple.\n\r *\n\r * @param  {Number} n        The number to round.\n\r * @param  {Number} multiple The multiple to round to.\n\r * @return {Number}          The result of the round operation.\n\r */\n\rroundToNearestMultiple: function (n, multiple) {\n\r\r'use strict';\n\n\r\rvar remainder = 0;\n\n\r\rif (multiple === 0) {\n\r\r\rreturn n;\n\r\r}\n\n\r\rremainder = Math.abs(n) % multiple;\n\n\r\rif (remainder === 0) {\n\r\r\rreturn n;\n\r\r}\n\n\r\rif (n < 0) {\n\r\r\rreturn -(Math.abs(n) - remainder);\n\r\r}\n\n\r\rreturn n + multiple - remainder;\n\r},\n\n\r/**\n\r * Check if all items in an array are equal. Uses strict equality.\n\r *\n\r * @param  {Array} array The array of values to check equality of.\n\r * @return {Boolean}       Whether the array's values are all equal or not.\n\r */\n\rarrayValuesAreEqual: function (array) {\n\r\r'use strict';\n\n\r\rfor (var i = 0; i < array.length - 1; ++i) {\n\r\r\rif (array[i] !== array[i + 1]) {\n\r\r\r\rreturn false;\n\r\r\r}\n\r\r}\n\n\r\rreturn true;\n\r},\n\n\r// colorsAreEqual: function() {\n\r//     var colors = Array.prototype.slice.call( arguments ),\n\r//         numColors = colors.length;\n\n\r//     for ( var i = 0, color1, color2; i < numColors - 1; ++i ) {\n\r//         color1 = colors[ i ];\n\r//         color2 = colors[ i + 1 ];\n\n\r//         if (\n\r//             color1.r !== color2.r ||\n\r//             color1.g !== color2.g ||\n\r//             color1.b !== color2.b\n\r//         ) {\n\r//             return false\n\r//         }\n\r//     }\n\n\r//     return true;\n\r// },\n\n\n\r/**\n\r * Given a start value and a spread value, create and return a random\n\r * number.\n\r * @param  {Number} base   The start value.\n\r * @param  {Number} spread The size of the random variance to apply.\n\r * @return {Number}        A randomised number.\n\r */\n\rrandomFloat: function (base, spread) {\n\r\r'use strict';\n\r\rreturn base + spread * (Math.random() - 0.5);\n\r},\n\n\n\n\r/**\n\r * Given an SPE.ShaderAttribute instance, and various other settings,\n\r * assign values to the attribute's array in a `vec3` format.\n\r *\n\r * @param  {Object} attribute   The instance of SPE.ShaderAttribute to save the result to.\n\r * @param  {Number} index       The offset in the attribute's TypedArray to save the result from.\n\r * @param  {Object} base        THREE.Vector3 instance describing the start value.\n\r * @param  {Object} spread      THREE.Vector3 instance describing the random variance to apply to the start value.\n\r * @param  {Object} spreadClamp THREE.Vector3 instance describing the multiples to clamp the randomness to.\n\r */\n\rrandomVector3: function (attribute, index, base, spread, spreadClamp) {\n\r\r'use strict';\n\n\r\rvar x = base.x + (Math.random() * spread.x - (spread.x * 0.5)),\n\r\r\ry = base.y + (Math.random() * spread.y - (spread.y * 0.5)),\n\r\r\rz = base.z + (Math.random() * spread.z - (spread.z * 0.5));\n\n\r\r// var x = this.randomFloat( base.x, spread.x ),\n\r\r// y = this.randomFloat( base.y, spread.y ),\n\r\r// z = this.randomFloat( base.z, spread.z );\n\n\r\rif (spreadClamp) {\n\r\r\rx = -spreadClamp.x * 0.5 + this.roundToNearestMultiple(x, spreadClamp.x);\n\r\r\ry = -spreadClamp.y * 0.5 + this.roundToNearestMultiple(y, spreadClamp.y);\n\r\r\rz = -spreadClamp.z * 0.5 + this.roundToNearestMultiple(z, spreadClamp.z);\n\r\r}\n\n\r\rattribute.typedArray.setVec3Components(index, x, y, z);\n\r},\n\n\r/**\n\r * Given an SPE.Shader attribute instance, and various other settings,\n\r * assign Color values to the attribute.\n\r * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n\r * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n\r * @param  {Object} base      THREE.Color instance describing the start color.\n\r * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.\n\r */\n\rrandomColor: function (attribute, index, base, spread) {\n\r\r'use strict';\n\n\r\rvar r = base.r + (Math.random() * spread.x),\n\r\r\rg = base.g + (Math.random() * spread.y),\n\r\r\rb = base.b + (Math.random() * spread.z);\n\n\r\rr = this.clamp(r, 0, 1);\n\r\rg = this.clamp(g, 0, 1);\n\r\rb = this.clamp(b, 0, 1);\n\n\n\r\rattribute.typedArray.setVec3Components(index, r, g, b);\n\r},\n\n\n\rrandomColorAsHex: (function () {\n\r\r'use strict';\n\n\r\rvar workingColor = new THREE.Color();\n\n\r\r/**\n\r\r * Assigns a random color value, encoded as a hex value in decimal\n\r\r * format, to a SPE.ShaderAttribute instance.\n\r\r * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n\r\r * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n\r\r * @param  {Object} base      THREE.Color instance describing the start color.\n\r\r * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.\n\r\r */\n\r\rreturn function (attribute, index, base, spread) {\n\r\r\rvar numItems = base.length,\n\r\r\r\rcolors = [];\n\n\r\r\rfor (var i = 0; i < numItems; ++i) {\n\r\r\r\rvar spreadVector = spread[i];\n\n\r\r\r\rworkingColor.copy(base[i]);\n\n\r\r\r\rworkingColor.r += (Math.random() * spreadVector.x) - (spreadVector.x * 0.5);\n\r\r\r\rworkingColor.g += (Math.random() * spreadVector.y) - (spreadVector.y * 0.5);\n\r\r\r\rworkingColor.b += (Math.random() * spreadVector.z) - (spreadVector.z * 0.5);\n\n\r\r\r\rworkingColor.r = this.clamp(workingColor.r, 0, 1);\n\r\r\r\rworkingColor.g = this.clamp(workingColor.g, 0, 1);\n\r\r\r\rworkingColor.b = this.clamp(workingColor.b, 0, 1);\n\n\r\r\r\rcolors.push(workingColor.getHex());\n\r\r\r}\n\n\r\r\rattribute.typedArray.setVec4Components(index, colors[0], colors[1], colors[2], colors[3]);\n\r\r};\n\r}()),\n\n\r/**\n\r * Given an SPE.ShaderAttribute instance, and various other settings,\n\r * assign values to the attribute's array in a `vec3` format.\n\r *\n\r * @param  {Object} attribute   The instance of SPE.ShaderAttribute to save the result to.\n\r * @param  {Number} index       The offset in the attribute's TypedArray to save the result from.\n\r * @param  {Object} start       THREE.Vector3 instance describing the start line position.\n\r * @param  {Object} end         THREE.Vector3 instance describing the end line position.\n\r */\n\rrandomVector3OnLine: function (attribute, index, start, end) {\n\r\r'use strict';\n\r\rvar pos = start.clone();\n\n\r\rpos.lerp(end, Math.random());\n\n\r\rattribute.typedArray.setVec3Components(index, pos.x, pos.y, pos.z);\n\r},\n\n\r/**\n\r * Given an SPE.Shader attribute instance, and various other settings,\n\r * assign Color values to the attribute.\n\r * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n\r * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n\r * @param  {Object} base      THREE.Color instance describing the start color.\n\r * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.\n\r */\n\n\r/**\n\r * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the\n\r * given values onto a sphere.\n\r *\n\r * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n\r * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n\r * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.\n\r * @param  {Number} radius            The radius of the sphere to project onto.\n\r * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result\n\r * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the sphere.\n\r * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.\n\r */\n\rrandomVector3OnSphere: function (\n\r\rattribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp, distributionClamp\n\r) {\n\r\r'use strict';\n\n\r\rvar depth = 2 * Math.random() - 1,\n\r\r\rt = 6.2832 * Math.random(),\n\r\r\rr = Math.sqrt(1 - depth * depth),\n\r\r\rrand = this.randomFloat(radius, radiusSpread),\n\r\r\rx = 0,\n\r\r\ry = 0,\n\r\r\rz = 0;\n\n\n\r\rif (radiusSpreadClamp) {\n\r\r\rrand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp;\n\r\r}\n\n\n\n\r\r// Set position on sphere\n\r\rx = r * Math.cos(t) * rand;\n\r\ry = r * Math.sin(t) * rand;\n\r\rz = depth * rand;\n\n\r\r// Apply radius scale to this position\n\r\rx *= radiusScale.x;\n\r\ry *= radiusScale.y;\n\r\rz *= radiusScale.z;\n\n\r\r// Translate to the base position.\n\r\rx += base.x;\n\r\ry += base.y;\n\r\rz += base.z;\n\n\r\r// Set the values in the typed array.\n\r\rattribute.typedArray.setVec3Components(index, x, y, z);\n\r},\n\n\rseededRandom: function (seed) {\n\r\rvar x = Math.sin(seed) * 10000;\n\r\rreturn x - (x | 0);\n\r},\n\n\n\n\r/**\n\r * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the\n\r * given values onto a 2d-disc.\n\r *\n\r * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n\r * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n\r * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.\n\r * @param  {Number} radius            The radius of the sphere to project onto.\n\r * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result\n\r * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the disc. The z-component is ignored.\n\r * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.\n\r */\n\rrandomVector3OnDisc: function (attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp) {\n\r\r'use strict';\n\n\r\rvar t = 6.2832 * Math.random(),\n\r\r\rrand = Math.abs(this.randomFloat(radius, radiusSpread)),\n\r\r\rx = 0,\n\r\r\ry = 0,\n\r\r\rz = 0;\n\n\r\rif (radiusSpreadClamp) {\n\r\r\rrand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp;\n\r\r}\n\n\r\r// Set position on sphere\n\r\rx = Math.cos(t) * rand;\n\r\ry = Math.sin(t) * rand;\n\n\r\r// Apply radius scale to this position\n\r\rx *= radiusScale.x;\n\r\ry *= radiusScale.y;\n\n\r\r// Translate to the base position.\n\r\rx += base.x;\n\r\ry += base.y;\n\r\rz += base.z;\n\n\r\r// Set the values in the typed array.\n\r\rattribute.typedArray.setVec3Components(index, x, y, z);\n\r},\n\n\rrandomDirectionVector3OnSphere: (function () {\n\r\r'use strict';\n\n\r\rvar v = new THREE.Vector3();\n\n\r\r/**\n\r\r * Given an SPE.ShaderAttribute instance, create a direction vector from the given\n\r\r * position, using `speed` as the magnitude. Values are saved to the attribute.\n\r\r *\n\r\r * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.\n\r\r * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.\n\r\r * @param  {Number} posX            The particle's x coordinate.\n\r\r * @param  {Number} posY            The particle's y coordinate.\n\r\r * @param  {Number} posZ            The particle's z coordinate.\n\r\r * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.\n\r\r * @param  {Number} speed           The magnitude to apply to the vector.\n\r\r * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.\n\r\r */\n\r\rreturn function (attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread) {\n\r\r\rv.copy(emitterPosition);\n\n\r\r\rv.x -= posX;\n\r\r\rv.y -= posY;\n\r\r\rv.z -= posZ;\n\n\r\r\rv.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread));\n\n\r\r\rattribute.typedArray.setVec3Components(index, v.x, v.y, v.z);\n\r\r};\n\r}()),\n\n\n\rrandomDirectionVector3OnDisc: (function () {\n\r\r'use strict';\n\n\r\rvar v = new THREE.Vector3();\n\n\r\r/**\n\r\r * Given an SPE.ShaderAttribute instance, create a direction vector from the given\n\r\r * position, using `speed` as the magnitude. Values are saved to the attribute.\n\r\r *\n\r\r * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.\n\r\r * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.\n\r\r * @param  {Number} posX            The particle's x coordinate.\n\r\r * @param  {Number} posY            The particle's y coordinate.\n\r\r * @param  {Number} posZ            The particle's z coordinate.\n\r\r * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.\n\r\r * @param  {Number} speed           The magnitude to apply to the vector.\n\r\r * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.\n\r\r */\n\r\rreturn function (attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread) {\n\r\r\rv.copy(emitterPosition);\n\n\r\r\rv.x -= posX;\n\r\r\rv.y -= posY;\n\r\r\rv.z -= posZ;\n\n\r\r\rv.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread));\n\n\r\r\rattribute.typedArray.setVec3Components(index, v.x, v.y, 0);\n\r\r};\n\r}()),\n\n\rgetPackedRotationAxis: (function () {\n\r\r'use strict';\n\n\r\rvar v = new THREE.Vector3(),\n\r\r\rvSpread = new THREE.Vector3(),\n\r\r\rc = new THREE.Color(),\n\r\r\raddOne = new THREE.Vector3(1, 1, 1);\n\n\r\r/**\n\r\r * Given a rotation axis, and a rotation axis spread vector,\n\r\r * calculate a randomised rotation axis, and pack it into\n\r\r * a hexadecimal value represented in decimal form.\n\r\r * @param  {Object} axis       THREE.Vector3 instance describing the rotation axis.\n\r\r * @param  {Object} axisSpread THREE.Vector3 instance describing the amount of randomness to apply to the rotation axis.\n\r\r * @return {Number}            The packed rotation axis, with randomness.\n\r\r */\n\r\rreturn function (axis, axisSpread) {\n\r\r\rv.copy(axis).normalize();\n\r\r\rvSpread.copy(axisSpread).normalize();\n\n\r\r\rv.x += (-axisSpread.x * 0.5) + (Math.random() * axisSpread.x);\n\r\r\rv.y += (-axisSpread.y * 0.5) + (Math.random() * axisSpread.y);\n\r\r\rv.z += (-axisSpread.z * 0.5) + (Math.random() * axisSpread.z);\n\n\r\r\r// v.x = Math.abs( v.x );\n\r\r\r// v.y = Math.abs( v.y );\n\r\r\r// v.z = Math.abs( v.z );\n\n\r\r\rv.normalize().add(addOne).multiplyScalar(0.5);\n\n\r\r\rc.setRGB(v.x, v.y, v.z);\n\n\r\r\rreturn c.getHex();\n\r\r};\n\r}())\n};\n\n\n/**\n * An SPE.Group instance.\n * @typedef {Object} Group\n * @see SPE.Group\n */\n\n/**\n * A map of options to configure an SPE.Group instance.\n * @typedef {Object} GroupOptions\n *\n * @property {Object} texture An object describing the texture used by the group.\n *\n * @property {Object} texture.value An instance of THREE.Texture.\n *\n * @property {Object=} texture.frames A THREE.Vector2 instance describing the number\n *                                    of frames on the x- and y-axis of the given texture.\n *                                    If not provided, the texture will NOT be treated as\n *                                    a sprite-sheet and as such will NOT be animated.\n *\n * @property {Number} [texture.frameCount=texture.frames.x * texture.frames.y] The total number of frames in the sprite-sheet.\n *                                                                   Allows for sprite-sheets that don't fill the entire\n *                                                                   texture.\n *\n * @property {Number} texture.loop The number of loops through the sprite-sheet that should\n *                                 be performed over the course of a single particle's lifetime.\n *\n * @property {Number} fixedTimeStep If no `dt` (or `deltaTime`) value is passed to this group's\n *                                  `tick()` function, this number will be used to move the particle\n *                                  simulation forward. Value in SECONDS.\n *\n * @property {Boolean} hasPerspective Whether the distance a particle is from the camera should affect\n *                                    the particle's size.\n *\n * @property {Boolean} colorize Whether the particles in this group should be rendered with color, or\n *                              whether the only color of particles will come from the provided texture.\n *\n * @property {Number} blending One of Three.js's blending modes to apply to this group's `ShaderMaterial`.\n *\n * @property {Boolean} transparent Whether these particle's should be rendered with transparency.\n *\n * @property {Number} alphaTest Sets the alpha value to be used when running an alpha test on the `texture.value` property. Value between 0 and 1.\n *\n * @property {Boolean} depthWrite Whether rendering the group has any effect on the depth buffer.\n *\n * @property {Boolean} depthTest Whether to have depth test enabled when rendering this group.\n *\n * @property {Boolean} fog Whether this group's particles should be affected by their scene's fog.\n *\n * @property {Number} scale The scale factor to apply to this group's particle sizes. Useful for\n *                          setting particle sizes to be relative to renderer size.\n */\n\n\n/**\n * The SPE.Group class. Creates a new group, containing a material, geometry, and mesh.\n *\n * @constructor\n * @param {GroupOptions} options A map of options to configure the group instance.\n */\nSPE.Group = function (options) {\n\r'use strict';\n\n\rvar utils = SPE.utils,\n\r\rtypes = utils.types;\n\n\r// Ensure we have a map of options to play with\n\roptions = utils.ensureTypedArg(options, types.OBJECT, {});\n\roptions.texture = utils.ensureTypedArg(options.texture, types.OBJECT, {});\n\n\r// Assign a UUID to this instance\n\rthis.uuid = THREE.Math.generateUUID();\n\n\r// If no `deltaTime` value is passed to the `SPE.Group.tick` function,\n\r// the value of this property will be used to advance the simulation.\n\rthis.fixedTimeStep = utils.ensureTypedArg(options.fixedTimeStep, types.NUMBER, 0.016);\n\n\r// Set properties used in the uniforms map, starting with the\n\r// texture stuff.\n\rthis.texture = utils.ensureInstanceOf(options.texture.value, THREE.Texture, null);\n\rthis.textureFrames = utils.ensureInstanceOf(options.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1));\n\rthis.textureFrameCount = utils.ensureTypedArg(options.texture.frameCount, types.NUMBER, this.textureFrames.x * this.textureFrames.y);\n\rthis.textureLoop = utils.ensureTypedArg(options.texture.loop, types.NUMBER, 1);\n\rthis.textureFrames.max(new THREE.Vector2(1, 1));\n\n\rthis.hasPerspective = utils.ensureTypedArg(options.hasPerspective, types.BOOLEAN, true);\n\rthis.colorize = utils.ensureTypedArg(options.colorize, types.BOOLEAN, true);\n\n\rthis.maxParticleCount = utils.ensureTypedArg(options.maxParticleCount, types.NUMBER, null);\n\n\n\r// Set properties used to define the ShaderMaterial's appearance.\n\rthis.blending = utils.ensureTypedArg(options.blending, types.NUMBER, THREE.AdditiveBlending);\n\rthis.transparent = utils.ensureTypedArg(options.transparent, types.BOOLEAN, true);\n\rthis.alphaTest = parseFloat(utils.ensureTypedArg(options.alphaTest, types.NUMBER, 0.0));\n\rthis.depthWrite = utils.ensureTypedArg(options.depthWrite, types.BOOLEAN, false);\n\rthis.depthTest = utils.ensureTypedArg(options.depthTest, types.BOOLEAN, true);\n\rthis.fog = utils.ensureTypedArg(options.fog, types.BOOLEAN, true);\n\rthis.scale = utils.ensureTypedArg(options.scale, types.NUMBER, 300);\n\n\r// Where emitter's go to curl up in a warm blanket and live\n\r// out their days.\n\rthis.emitters = [];\n\rthis.emitterIDs = [];\n\n\r// Create properties for use by the emitter pooling functions.\n\rthis._pool = [];\n\rthis._poolCreationSettings = null;\n\rthis._createNewWhenPoolEmpty = 0;\n\n\r// Whether all attributes should be forced to updated\n\r// their entire buffer contents on the next tick.\n\r//\n\r// Used when an emitter is removed.\n\rthis._attributesNeedRefresh = false;\n\rthis._attributesNeedDynamicReset = false;\n\n\rthis.particleCount = 0;\n\n\n\r// Map of uniforms to be applied to the ShaderMaterial instance.\n\rthis.uniforms = {\n\r\rtex: {\n\r\r\rtype: 't',\n\r\r\rvalue: this.texture\n\r\r},\n\r\rtextureAnimation: {\n\r\r\rtype: 'v4',\n\r\r\rvalue: new THREE.Vector4(\n\r\r\r\rthis.textureFrames.x,\n\r\r\r\rthis.textureFrames.y,\n\r\r\r\rthis.textureFrameCount,\n\r\r\r\rMath.max(Math.abs(this.textureLoop), 1.0)\n\r\r\r)\n\r\r},\n\r\rfogColor: {\n\r\r\rtype: 'c',\n\r\r\rvalue: this.fog ? new THREE.Color() : null\n\r\r},\n\r\rfogNear: {\n\r\r\rtype: 'f',\n\r\r\rvalue: 10\n\r\r},\n\r\rfogFar: {\n\r\r\rtype: 'f',\n\r\r\rvalue: 200\n\r\r},\n\r\rfogDensity: {\n\r\r\rtype: 'f',\n\r\r\rvalue: 0.5\n\r\r},\n\r\rdeltaTime: {\n\r\r\rtype: 'f',\n\r\r\rvalue: 0\n\r\r},\n\r\rrunTime: {\n\r\r\rtype: 'f',\n\r\r\rvalue: 0\n\r\r},\n\r\rscale: {\n\r\r\rtype: 'f',\n\r\r\rvalue: this.scale\n\r\r}\n\r};\n\n\r// Add some defines into the mix...\n\rthis.defines = {\n\r\rHAS_PERSPECTIVE: this.hasPerspective,\n\r\rCOLORIZE: this.colorize,\n\r\rVALUE_OVER_LIFETIME_LENGTH: SPE.valueOverLifetimeLength,\n\n\r\rSHOULD_ROTATE_TEXTURE: false,\n\r\rSHOULD_ROTATE_PARTICLES: false,\n\r\rSHOULD_WIGGLE_PARTICLES: false,\n\n\r\rSHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1\n\r};\n\n\r// Map of all attributes to be applied to the particles.\n\r//\n\r// See SPE.ShaderAttribute for a bit more info on this bit.\n\rthis.attributes = {\n\r\rposition: new SPE.ShaderAttribute('v3', true),\n\r\racceleration: new SPE.ShaderAttribute('v4', true), // w component is drag\n\r\rvelocity: new SPE.ShaderAttribute('v3', true),\n\r\rrotation: new SPE.ShaderAttribute('v4', true),\n\r\rrotationCenter: new SPE.ShaderAttribute('v3', true),\n\r\rparams: new SPE.ShaderAttribute('v4', true), // Holds (alive, age, delay, wiggle)\n\r\rsize: new SPE.ShaderAttribute('v4', true),\n\r\rangle: new SPE.ShaderAttribute('v4', true),\n\r\rcolor: new SPE.ShaderAttribute('v4', true),\n\r\ropacity: new SPE.ShaderAttribute('v4', true)\n\r};\n\n\rthis.attributeKeys = Object.keys(this.attributes);\n\rthis.attributeCount = this.attributeKeys.length;\n\n\r// Create the ShaderMaterial instance that'll help render the\n\r// particles.\n\rthis.material = new THREE.ShaderMaterial({\n\r\runiforms: this.uniforms,\n\r\rvertexShader: SPE.shaders.vertex,\n\r\rfragmentShader: SPE.shaders.fragment,\n\r\rblending: this.blending,\n\r\rtransparent: this.transparent,\n\r\ralphaTest: this.alphaTest,\n\r\rdepthWrite: this.depthWrite,\n\r\rdepthTest: this.depthTest,\n\r\rdefines: this.defines,\n\r\rfog: this.fog\n\r});\n\n\r// Create the BufferGeometry and Points instances, ensuring\n\r// the geometry and material are given to the latter.\n\rthis.geometry = new THREE.BufferGeometry();\n\rthis.mesh = new THREE.Points(this.geometry, this.material);\n\n\rif (this.maxParticleCount === null) {\n\r\rconsole.warn('SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.');\n\r}\n};\n\nSPE.Group.constructor = SPE.Group;\n\n\nSPE.Group.prototype._updateDefines = function () {\n\r'use strict';\n\n\rvar emitters = this.emitters,\n\r\ri = emitters.length - 1,\n\r\remitter,\n\r\rdefines = this.defines;\n\n\rfor (i; i >= 0; --i) {\n\r\remitter = emitters[i];\n\n\r\r// Only do angle calculation if there's no spritesheet defined.\n\r\r//\n\r\r// Saves calculations being done and then overwritten in the shaders.\n\r\rif (!defines.SHOULD_CALCULATE_SPRITE) {\n\r\r\rdefines.SHOULD_ROTATE_TEXTURE = defines.SHOULD_ROTATE_TEXTURE || !!Math.max(\n\r\r\r\rMath.max.apply(null, emitter.angle.value),\n\r\r\r\rMath.max.apply(null, emitter.angle.spread)\n\r\r\r);\n\r\r}\n\n\r\rdefines.SHOULD_ROTATE_PARTICLES = defines.SHOULD_ROTATE_PARTICLES || !!Math.max(\n\r\r\remitter.rotation.angle,\n\r\r\remitter.rotation.angleSpread\n\r\r);\n\n\r\rdefines.SHOULD_WIGGLE_PARTICLES = defines.SHOULD_WIGGLE_PARTICLES || !!Math.max(\n\r\r\remitter.wiggle.value,\n\r\r\remitter.wiggle.spread\n\r\r);\n\r}\n\n\rthis.material.needsUpdate = true;\n};\n\nSPE.Group.prototype._applyAttributesToGeometry = function () {\n\r'use strict';\n\n\rvar attributes = this.attributes,\n\r\rgeometry = this.geometry,\n\r\rgeometryAttributes = geometry.attributes,\n\r\rattribute,\n\r\rgeometryAttribute;\n\n\r// Loop through all the shader attributes and assign (or re-assign)\n\r// typed array buffers to each one.\n\rfor (var attr in attributes) {\n\r\rif (attributes.hasOwnProperty(attr)) {\n\r\r\rattribute = attributes[attr];\n\r\r\rgeometryAttribute = geometryAttributes[attr];\n\n\r\r\r// Update the array if this attribute exists on the geometry.\n\r\r\r//\n\r\r\r// This needs to be done because the attribute's typed array might have\n\r\r\r// been resized and reinstantiated, and might now be looking at a\n\r\r\r// different ArrayBuffer, so reference needs updating.\n\r\r\rif (geometryAttribute) {\n\r\r\r\rgeometryAttribute.array = attribute.typedArray.array;\n\r\r\r}\n\n\r\r\r// // Add the attribute to the geometry if it doesn't already exist.\n\r\r\relse {\n\r\r\r\rgeometry.addAttribute(attr, attribute.bufferAttribute);\n\r\r\r}\n\n\r\r\r// Mark the attribute as needing an update the next time a frame is rendered.\n\r\r\rattribute.bufferAttribute.needsUpdate = true;\n\r\r}\n\r}\n\n\r// Mark the draw range on the geometry. This will ensure\n\r// only the values in the attribute buffers that are\n\r// associated with a particle will be used in THREE's\n\r// render cycle.\n\rthis.geometry.setDrawRange(0, this.particleCount);\n};\n\n/**\n * Adds an SPE.Emitter instance to this group, creating particle values and\n * assigning them to this group's shader attributes.\n *\n * @param {Emitter} emitter The emitter to add to this group.\n */\nSPE.Group.prototype.addEmitter = function (emitter) {\n\r'use strict';\n\n\r// Ensure an actual emitter instance is passed here.\n\r//\n\r// Decided not to throw here, just in case a scene's\n\r// rendering would be paused. Logging an error instead\n\r// of stopping execution if exceptions aren't caught.\n\rif (emitter instanceof SPE.Emitter === false) {\n\r\rconsole.error('`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter);\n\r\rreturn;\n\r}\n\n\r// If the emitter already exists as a member of this group, then\n\r// stop here, we don't want to add it again.\n\relse if (this.emitterIDs.indexOf(emitter.uuid) > -1) {\n\r\rconsole.error('Emitter already exists in this group. Will not add again.');\n\r\rreturn;\n\r}\n\n\r// And finally, if the emitter is a member of another group,\n\r// don't add it to this group.\n\relse if (emitter.group !== null) {\n\r\rconsole.error('Emitter already belongs to another group. Will not add to requested group.');\n\r\rreturn;\n\r}\n\n\rvar attributes = this.attributes,\n\r\rstart = this.particleCount,\n\r\rend = start + emitter.particleCount;\n\n\r// Update this group's particle count.\n\rthis.particleCount = end;\n\n\r// Emit a warning if the emitter being added will exceed the buffer sizes specified.\n\rif (this.maxParticleCount !== null && this.particleCount > this.maxParticleCount) {\n\r\rconsole.warn('SPE.Group: maxParticleCount exceeded. Requesting', this.particleCount, 'particles, can support only', this.maxParticleCount);\n\r}\n\n\n\r// Set the `particlesPerSecond` value (PPS) on the emitter.\n\r// It's used to determine how many particles to release\n\r// on a per-frame basis.\n\remitter._calculatePPSValue(emitter.maxAge._value + emitter.maxAge._spread);\n\remitter._setBufferUpdateRanges(this.attributeKeys);\n\n\r// Store the offset value in the TypedArray attributes for this emitter.\n\remitter._setAttributeOffset(start);\n\n\r// Save a reference to this group on the emitter so it knows\n\r// where it belongs.\n\remitter.group = this;\n\n\r// Store reference to the attributes on the emitter for\n\r// easier access during the emitter's tick function.\n\remitter.attributes = this.attributes;\n\n\n\n\r// Ensure the attributes and their BufferAttributes exist, and their\n\r// TypedArrays are of the correct size.\n\rfor (var attr in attributes) {\n\r\rif (attributes.hasOwnProperty(attr)) {\n\r\r\r// When creating a buffer, pass through the maxParticle count\n\r\r\r// if one is specified.\n\r\r\rattributes[attr]._createBufferAttribute(\n\r\r\r\rthis.maxParticleCount !== null ?\n\r\r\r\r\rthis.maxParticleCount :\n\r\r\r\r\rthis.particleCount\n\r\r\r);\n\r\r}\n\r}\n\n\r// Loop through each particle this emitter wants to have, and create the attributes values,\n\r// storing them in the TypedArrays that each attribute holds.\n\rfor (var i = start; i < end; ++i) {\n\r\remitter._assignPositionValue(i);\n\r\remitter._assignForceValue(i, 'velocity');\n\r\remitter._assignForceValue(i, 'acceleration');\n\r\remitter._assignAbsLifetimeValue(i, 'opacity');\n\r\remitter._assignAbsLifetimeValue(i, 'size');\n\r\remitter._assignAngleValue(i);\n\r\remitter._assignRotationValue(i);\n\r\remitter._assignParamsValue(i);\n\r\remitter._assignColorValue(i);\n\r}\n\n\r// Update the geometry and make sure the attributes are referencing\n\r// the typed arrays properly.\n\rthis._applyAttributesToGeometry();\n\n\r// Store this emitter in this group's emitter's store.\n\rthis.emitters.push(emitter);\n\rthis.emitterIDs.push(emitter.uuid);\n\n\r// Update certain flags to enable shader calculations only if they're necessary.\n\rthis._updateDefines(emitter);\n\n\r// Update the material since defines might have changed\n\rthis.material.needsUpdate = true;\n\rthis.geometry.needsUpdate = true;\n\rthis._attributesNeedRefresh = true;\n\n\r// Return the group to enable chaining.\n\rreturn this;\n};\n\n/**\n * Removes an SPE.Emitter instance from this group. When called,\n * all particle's belonging to the given emitter will be instantly\n * removed from the scene.\n *\n * @param {Emitter} emitter The emitter to add to this group.\n */\nSPE.Group.prototype.removeEmitter = function (emitter) {\n\r'use strict';\n\n\rvar emitterIndex = this.emitterIDs.indexOf(emitter.uuid);\n\n\r// Ensure an actual emitter instance is passed here.\n\r//\n\r// Decided not to throw here, just in case a scene's\n\r// rendering would be paused. Logging an error instead\n\r// of stopping execution if exceptions aren't caught.\n\rif (emitter instanceof SPE.Emitter === false) {\n\r\rconsole.error('`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter);\n\r\rreturn;\n\r}\n\n\r// Issue an error if the emitter isn't a member of this group.\n\relse if (emitterIndex === -1) {\n\r\rconsole.error('Emitter does not exist in this group. Will not remove.');\n\r\rreturn;\n\r}\n\n\r// Kill all particles by marking them as dead\n\r// and their age as 0.\n\rvar start = emitter.attributeOffset,\n\r\rend = start + emitter.particleCount,\n\r\rparams = this.attributes.params.typedArray;\n\n\r// Set alive and age to zero.\n\rfor (var i = start; i < end; ++i) {\n\r\rparams.array[i * 4] = 0.0;\n\r\rparams.array[i * 4 + 1] = 0.0;\n\r}\n\n\r// Remove the emitter from this group's 'store'.\n\rthis.emitters.splice(emitterIndex, 1);\n\rthis.emitterIDs.splice(emitterIndex, 1);\n\n\r// Remove this emitter's attribute values from all shader attributes.\n\r// The `.splice()` call here also marks each attribute's buffer\n\r// as needing to update it's entire contents.\n\rfor (var attr in this.attributes) {\n\r\rif (this.attributes.hasOwnProperty(attr)) {\n\r\r\rthis.attributes[attr].splice(start, end);\n\r\r}\n\r}\n\n\r// Ensure this group's particle count is correct.\n\rthis.particleCount -= emitter.particleCount;\n\n\r// Call the emitter's remove method.\n\remitter._onRemove();\n\n\r// Set a flag to indicate that the attribute buffers should\n\r// be updated in their entirety on the next frame.\n\rthis._attributesNeedRefresh = true;\n};\n\n\n/**\n * Fetch a single emitter instance from the pool.\n * If there are no objects in the pool, a new emitter will be\n * created if specified.\n *\n * @return {Emitter|null}\n */\nSPE.Group.prototype.getFromPool = function () {\n\r'use strict';\n\n\rvar pool = this._pool,\n\r\rcreateNew = this._createNewWhenPoolEmpty;\n\n\rif (pool.length) {\n\r\rreturn pool.pop();\n\r}\n\relse if (createNew) {\n\r\rvar emitter = new SPE.Emitter(this._poolCreationSettings);\n\n\r\rthis.addEmitter(emitter);\n\n\r\rreturn emitter;\n\r}\n\n\rreturn null;\n};\n\n\n/**\n * Release an emitter into the pool.\n *\n * @param  {ShaderParticleEmitter} emitter\n * @return {Group} This group instance.\n */\nSPE.Group.prototype.releaseIntoPool = function (emitter) {\n\r'use strict';\n\n\rif (emitter instanceof SPE.Emitter === false) {\n\r\rconsole.error('Argument is not instanceof SPE.Emitter:', emitter);\n\r\rreturn;\n\r}\n\n\remitter.reset();\n\rthis._pool.unshift(emitter);\n\n\rreturn this;\n};\n\n\n/**\n * Get the pool array\n *\n * @return {Array}\n */\nSPE.Group.prototype.getPool = function () {\n\r'use strict';\n\rreturn this._pool;\n};\n\n\n/**\n * Add a pool of emitters to this particle group\n *\n * @param {Number} numEmitters      The number of emitters to add to the pool.\n * @param {EmitterOptions|Array} emitterOptions  An object, or array of objects, describing the options to pass to each emitter.\n * @param {Boolean} createNew       Should a new emitter be created if the pool runs out?\n * @return {Group} This group instance.\n */\nSPE.Group.prototype.addPool = function (numEmitters, emitterOptions, createNew) {\n\r'use strict';\n\n\rvar emitter;\n\n\r// Save relevant settings and flags.\n\rthis._poolCreationSettings = emitterOptions;\n\rthis._createNewWhenPoolEmpty = !!createNew;\n\n\r// Create the emitters, add them to this group and the pool.\n\rfor (var i = 0; i < numEmitters; ++i) {\n\r\rif (Array.isArray(emitterOptions)) {\n\r\r\remitter = new SPE.Emitter(emitterOptions[i]);\n\r\r}\n\r\relse {\n\r\r\remitter = new SPE.Emitter(emitterOptions);\n\r\r}\n\r\rthis.addEmitter(emitter);\n\r\rthis.releaseIntoPool(emitter);\n\r}\n\n\rreturn this;\n};\n\n\n\nSPE.Group.prototype._triggerSingleEmitter = function (pos) {\n\r'use strict';\n\n\rvar emitter = this.getFromPool(),\n\r\rself = this;\n\n\rif (emitter === null) {\n\r\rconsole.log('SPE.Group pool ran out.');\n\r\rreturn;\n\r}\n\n\r// TODO:\n\r// - Make sure buffers are update with thus new position.\n\rif (pos instanceof THREE.Vector3) {\n\r\remitter.position.value.copy(pos);\n\n\r\r// Trigger the setter for this property to force an\n\r\r// update to the emitter's position attribute.\n\r\remitter.position.value = emitter.position.value;\n\r}\n\n\remitter.enable();\n\n\rsetTimeout(function () {\n\r\remitter.disable();\n\r\rself.releaseIntoPool(emitter);\n\r}, (Math.max(emitter.duration, (emitter.maxAge.value + emitter.maxAge.spread))) * 1000);\n\n\rreturn this;\n};\n\n\n/**\n * Set a given number of emitters as alive, with an optional position\n * vector3 to move them to.\n *\n * @param  {Number} numEmitters The number of emitters to activate\n * @param  {Object} [position=undefined] A THREE.Vector3 instance describing the position to activate the emitter(s) at.\n * @return {Group} This group instance.\n */\nSPE.Group.prototype.triggerPoolEmitter = function (numEmitters, position) {\n\r'use strict';\n\n\rif (typeof numEmitters === 'number' && numEmitters > 1) {\n\r\rfor (var i = 0; i < numEmitters; ++i) {\n\r\r\rthis._triggerSingleEmitter(position);\n\r\r}\n\r}\n\relse {\n\r\rthis._triggerSingleEmitter(position);\n\r}\n\n\rreturn this;\n};\n\n\n\nSPE.Group.prototype._updateUniforms = function (dt) {\n\r'use strict';\n\n\rthis.uniforms.runTime.value += dt;\n\rthis.uniforms.deltaTime.value = dt;\n};\n\nSPE.Group.prototype._resetBufferRanges = function () {\n\r'use strict';\n\n\rvar keys = this.attributeKeys,\n\r\ri = this.attributeCount - 1,\n\r\rattrs = this.attributes;\n\n\rfor (i; i >= 0; --i) {\n\r\rattrs[keys[i]].resetUpdateRange();\n\r}\n};\n\n\nSPE.Group.prototype._updateBuffers = function (emitter) {\n\r'use strict';\n\n\rvar keys = this.attributeKeys,\n\r\ri = this.attributeCount - 1,\n\r\rattrs = this.attributes,\n\r\remitterRanges = emitter.bufferUpdateRanges,\n\r\rkey,\n\r\remitterAttr,\n\r\rattr;\n\n\rfor (i; i >= 0; --i) {\n\r\rkey = keys[i];\n\r\remitterAttr = emitterRanges[key];\n\r\rattr = attrs[key];\n\r\rattr.setUpdateRange(emitterAttr.min, emitterAttr.max);\n\r\rattr.flagUpdate();\n\r}\n};\n\n\n/**\n * Simulate all the emitter's belonging to this group, updating\n * attribute values along the way.\n * @param  {Number} [dt=Group's `fixedTimeStep` value] The number of seconds to simulate the group's emitters for (deltaTime)\n */\nSPE.Group.prototype.tick = function (dt) {\n\r'use strict';\n\n\rvar emitters = this.emitters,\n\r\rnumEmitters = emitters.length,\n\r\rdeltaTime = dt || this.fixedTimeStep,\n\r\rkeys = this.attributeKeys,\n\r\ri,\n\r\rattrs = this.attributes;\n\n\r// Update uniform values.\n\rthis._updateUniforms(deltaTime);\n\n\r// Reset buffer update ranges on the shader attributes.\n\rthis._resetBufferRanges();\n\n\n\r// If nothing needs updating, then stop here.\n\rif (\n\r\rnumEmitters === 0 &&\n\r\rthis._attributesNeedRefresh === false &&\n\r\rthis._attributesNeedDynamicReset === false\n\r) {\n\r\rreturn;\n\r}\n\n\r// Loop through each emitter in this group and\n\r// simulate it, then update the shader attribute\n\r// buffers.\n\rfor (var i = 0, emitter; i < numEmitters; ++i) {\n\r\remitter = emitters[i];\n\r\remitter.tick(deltaTime);\n\r\rthis._updateBuffers(emitter);\n\r}\n\n\r// If the shader attributes have been refreshed,\n\r// then the dynamic properties of each buffer\n\r// attribute will need to be reset back to\n\r// what they should be.\n\rif (this._attributesNeedDynamicReset === true) {\n\r\ri = this.attributeCount - 1;\n\n\r\rfor (i; i >= 0; --i) {\n\r\r\rattrs[keys[i]].resetDynamic();\n\r\r}\n\n\r\rthis._attributesNeedDynamicReset = false;\n\r}\n\n\r// If this group's shader attributes need a full refresh\n\r// then mark each attribute's buffer attribute as\n\r// needing so.\n\rif (this._attributesNeedRefresh === true) {\n\r\ri = this.attributeCount - 1;\n\n\r\rfor (i; i >= 0; --i) {\n\r\r\rattrs[keys[i]].forceUpdateAll();\n\r\r}\n\n\r\rthis._attributesNeedRefresh = false;\n\r\rthis._attributesNeedDynamicReset = true;\n\r}\n};\n\n\n/**\n * Dipose the geometry and material for the group.\n *\n * @return {Group} Group instance.\n */\nSPE.Group.prototype.dispose = function () {\n\r'use strict';\n\rthis.geometry.dispose();\n\rthis.material.dispose();\n\rreturn this;\n};\n\n\n/**\n * An SPE.Emitter instance.\n * @typedef {Object} Emitter\n * @see SPE.Emitter\n */\n\n/**\n * A map of options to configure an SPE.Emitter instance.\n *\n * @typedef {Object} EmitterOptions\n *\n * @property {distribution} [type=BOX] The default distribution this emitter should use to control\n *                         its particle's spawn position and force behaviour.\n *                         Must be an SPE.distributions.* value.\n *\n *\n * @property {Number} [particleCount=100] The total number of particles this emitter will hold. NOTE: this is not the number\n *                                  of particles emitted in a second, or anything like that. The number of particles\n *                                  emitted per-second is calculated by particleCount / maxAge (approximately!)\n *\n * @property {Number|null} [duration=null] The duration in seconds that this emitter should live for. If not specified, the emitter\n *                                         will emit particles indefinitely.\n *                                         NOTE: When an emitter is older than a specified duration, the emitter is NOT removed from\n *                                         it's group, but rather is just marked as dead, allowing it to be reanimated at a later time\n *                                         using `SPE.Emitter.prototype.enable()`.\n *\n * @property {Boolean} [isStatic=false] Whether this emitter should be not be simulated (true).\n * @property {Boolean} [activeMultiplier=1] A value between 0 and 1 describing what percentage of this emitter's particlesPerSecond should be\n *                                          emitted, where 0 is 0%, and 1 is 100%.\n *                                          For example, having an emitter with 100 particles, a maxAge of 2, yields a particlesPerSecond\n *                                          value of 50. Setting `activeMultiplier` to 0.5, then, will only emit 25 particles per second (0.5 = 50%).\n *                                          Values greater than 1 will emulate a burst of particles, causing the emitter to run out of particles\n *                                          before it's next activation cycle.\n *\n * @property {Boolean} [direction=1] The direction of the emitter. If value is `1`, emitter will start at beginning of particle's lifecycle.\n *                                   If value is `-1`, emitter will start at end of particle's lifecycle and work it's way backwards.\n *\n * @property {Object} [maxAge={}] An object describing the particle's maximum age in seconds.\n * @property {Number} [maxAge.value=2] A number between 0 and 1 describing the amount of maxAge to apply to all particles.\n * @property {Number} [maxAge.spread=0] A number describing the maxAge variance on a per-particle basis.\n *\n *\n * @property {Object} [position={}] An object describing this emitter's position.\n * @property {Object} [position.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base position.\n * @property {Object} [position.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's position variance on a per-particle basis.\n *                                                          Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                          of this vector is used.\n *                                                          When using a LINE distribution, this value is the endpoint of the LINE.\n * @property {Object} [position.spreadClamp=new THREE.Vector3()] A THREE.Vector3 instance describing the numeric multiples the particle's should\n *                                                               be spread out over.\n *                                                               Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                               of this vector is used.\n *                                                               When using a LINE distribution, this property is ignored.\n * @property {Number} [position.radius=10] This emitter's base radius.\n * @property {Object} [position.radiusScale=new THREE.Vector3()] A THREE.Vector3 instance describing the radius's scale in all three axes. Allows a SPHERE or DISC to be squashed or stretched.\n * @property {distribution} [position.distribution=value of the `type` option.] A specific distribution to use when radiusing particles. Overrides the `type` option.\n * @property {Boolean} [position.randomise=false] When a particle is re-spawned, whether it's position should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [velocity={}] An object describing this particle velocity.\n * @property {Object} [velocity.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base velocity.\n * @property {Object} [velocity.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's velocity variance on a per-particle basis.\n *                                                          Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                          of this vector is used.\n * @property {distribution} [velocity.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's velocity. Overrides the `type` option.\n * @property {Boolean} [velocity.randomise=false] When a particle is re-spawned, whether it's velocity should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [acceleration={}] An object describing this particle's acceleration.\n * @property {Object} [acceleration.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base acceleration.\n * @property {Object} [acceleration.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's acceleration variance on a per-particle basis.\n *                           Note that when using a SPHERE or DISC distribution, only the x-component\n *                           of this vector is used.\n * @property {distribution} [acceleration.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's acceleration. Overrides the `type` option.\n * @property {Boolean} [acceleration.randomise=false] When a particle is re-spawned, whether it's acceleration should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [drag={}] An object describing this particle drag. Drag is applied to both velocity and acceleration values.\n * @property {Number} [drag.value=0] A number between 0 and 1 describing the amount of drag to apply to all particles.\n * @property {Number} [drag.spread=0] A number describing the drag variance on a per-particle basis.\n * @property {Boolean} [drag.randomise=false] When a particle is re-spawned, whether it's drag should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [wiggle={}] This is quite a fun one! The values of this object will determine whether a particle will wiggle, or jiggle, or wave,\n *                                or shimmy, or waggle, or... Well you get the idea. The wiggle is calculated over-time, meaning that a particle will\n *                                start off with no wiggle, and end up wiggling about with the distance of the `value` specified by the time it dies.\n *                                It's quite handy to simulate fire embers, or similar effects where the particle's position should slightly change over\n *                                time, and such change isn't easily controlled by rotation, velocity, or acceleration. The wiggle is a combination of sin and cos calculations, so is circular in nature.\n * @property {Number} [wiggle.value=0] A number describing the amount of wiggle to apply to all particles. It's measured in distance.\n * @property {Number} [wiggle.spread=0] A number describing the wiggle variance on a per-particle basis.\n *\n *\n * @property {Object} [rotation={}] An object describing this emitter's rotation. It can either be static, or set to rotate from 0radians to the value of `rotation.value`\n *                                  over a particle's lifetime. Rotation values affect both a particle's position and the forces applied to it.\n * @property {Object} [rotation.axis=new THREE.Vector3(0, 1, 0)] A THREE.Vector3 instance describing this emitter's axis of rotation.\n * @property {Object} [rotation.axisSpread=new THREE.Vector3()] A THREE.Vector3 instance describing the amount of variance to apply to the axis of rotation on\n *                                                              a per-particle basis.\n * @property {Number} [rotation.angle=0] The angle of rotation, given in radians. If `rotation.static` is true, the emitter will start off rotated at this angle, and stay as such.\n *                                       Otherwise, the particles will rotate from 0radians to this value over their lifetimes.\n * @property {Number} [rotation.angleSpread=0] The amount of variance in each particle's rotation angle.\n * @property {Boolean} [rotation.static=false] Whether the rotation should be static or not.\n * @property {Object} [rotation.center=The value of `position.value`] A THREE.Vector3 instance describing the center point of rotation.\n * @property {Boolean} [rotation.randomise=false] When a particle is re-spawned, whether it's rotation should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [color={}] An object describing a particle's color. This property is a 'value-over-lifetime' property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of THREE.Color instances are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Object} [color.value=new THREE.Color()] Either a single THREE.Color instance, or an array of THREE.Color instances to describe the color of a particle over it's lifetime.\n * @property {Object} [color.spread=new THREE.Vector3()] Either a single THREE.Vector3 instance, or an array of THREE.Vector3 instances to describe the color variance of a particle over it's lifetime.\n * @property {Boolean} [color.randomise=false] When a particle is re-spawned, whether it's color should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [opacity={}] An object describing a particle's opacity. This property is a 'value-over-lifetime' property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [opacity.value=1] Either a single number, or an array of numbers to describe the opacity of a particle over it's lifetime.\n * @property {Number} [opacity.spread=0] Either a single number, or an array of numbers to describe the opacity variance of a particle over it's lifetime.\n * @property {Boolean} [opacity.randomise=false] When a particle is re-spawned, whether it's opacity should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [size={}] An object describing a particle's size. This property is a 'value-over-lifetime' property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [size.value=1] Either a single number, or an array of numbers to describe the size of a particle over it's lifetime.\n * @property {Number} [size.spread=0] Either a single number, or an array of numbers to describe the size variance of a particle over it's lifetime.\n * @property {Boolean} [size.randomise=false] When a particle is re-spawned, whether it's size should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [angle={}] An object describing a particle's angle. The angle is a 2d-rotation, measured in radians, applied to the particle's texture.\n *                               NOTE: if a particle's texture is a sprite-sheet, this value IS IGNORED.\n *                               This property is a 'value-over-lifetime' property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [angle.value=0] Either a single number, or an array of numbers to describe the angle of a particle over it's lifetime.\n * @property {Number} [angle.spread=0] Either a single number, or an array of numbers to describe the angle variance of a particle over it's lifetime.\n * @property {Boolean} [angle.randomise=false] When a particle is re-spawned, whether it's angle should be re-randomised or not. Can incur a performance hit.\n *\n */\n\n/**\n * The SPE.Emitter class.\n *\n * @constructor\n *\n * @param {EmitterOptions} options A map of options to configure the emitter.\n */\nSPE.Emitter = function (options) {\n\r'use strict';\n\n\rvar utils = SPE.utils,\n\r\rtypes = utils.types,\n\r\rlifetimeLength = SPE.valueOverLifetimeLength;\n\n\r// Ensure we have a map of options to play with,\n\r// and that each option is in the correct format.\n\roptions = utils.ensureTypedArg(options, types.OBJECT, {});\n\roptions.position = utils.ensureTypedArg(options.position, types.OBJECT, {});\n\roptions.velocity = utils.ensureTypedArg(options.velocity, types.OBJECT, {});\n\roptions.acceleration = utils.ensureTypedArg(options.acceleration, types.OBJECT, {});\n\roptions.radius = utils.ensureTypedArg(options.radius, types.OBJECT, {});\n\roptions.drag = utils.ensureTypedArg(options.drag, types.OBJECT, {});\n\roptions.rotation = utils.ensureTypedArg(options.rotation, types.OBJECT, {});\n\roptions.color = utils.ensureTypedArg(options.color, types.OBJECT, {});\n\roptions.opacity = utils.ensureTypedArg(options.opacity, types.OBJECT, {});\n\roptions.size = utils.ensureTypedArg(options.size, types.OBJECT, {});\n\roptions.angle = utils.ensureTypedArg(options.angle, types.OBJECT, {});\n\roptions.wiggle = utils.ensureTypedArg(options.wiggle, types.OBJECT, {});\n\roptions.maxAge = utils.ensureTypedArg(options.maxAge, types.OBJECT, {});\n\n\rif (options.onParticleSpawn) {\n\r\rconsole.warn('onParticleSpawn has been removed. Please set properties directly to alter values at runtime.');\n\r}\n\n\rthis.uuid = THREE.Math.generateUUID();\n\n\rthis.type = utils.ensureTypedArg(options.type, types.NUMBER, SPE.distributions.BOX);\n\n\r// Start assigning properties...kicking it off with props that DON'T support values over\n\r// lifetimes.\n\r//\n\r// Btw, values over lifetimes are just the new way of referring to *Start, *Middle, and *End.\n\rthis.position = {\n\r\r_value: utils.ensureInstanceOf(options.position.value, THREE.Vector3, new THREE.Vector3()),\n\r\r_spread: utils.ensureInstanceOf(options.position.spread, THREE.Vector3, new THREE.Vector3()),\n\r\r_spreadClamp: utils.ensureInstanceOf(options.position.spreadClamp, THREE.Vector3, new THREE.Vector3()),\n\r\r_distribution: utils.ensureTypedArg(options.position.distribution, types.NUMBER, this.type),\n\r\r_randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false),\n\r\r_radius: utils.ensureTypedArg(options.position.radius, types.NUMBER, 10),\n\r\r_radiusScale: utils.ensureInstanceOf(options.position.radiusScale, THREE.Vector3, new THREE.Vector3(1, 1, 1)),\n\r\r_distributionClamp: utils.ensureTypedArg(options.position.distributionClamp, types.NUMBER, 0),\n\r};\n\n\rthis.velocity = {\n\r\r_value: utils.ensureInstanceOf(options.velocity.value, THREE.Vector3, new THREE.Vector3()),\n\r\r_spread: utils.ensureInstanceOf(options.velocity.spread, THREE.Vector3, new THREE.Vector3()),\n\r\r_distribution: utils.ensureTypedArg(options.velocity.distribution, types.NUMBER, this.type),\n\r\r_randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n\r};\n\n\rthis.acceleration = {\n\r\r_value: utils.ensureInstanceOf(options.acceleration.value, THREE.Vector3, new THREE.Vector3()),\n\r\r_spread: utils.ensureInstanceOf(options.acceleration.spread, THREE.Vector3, new THREE.Vector3()),\n\r\r_distribution: utils.ensureTypedArg(options.acceleration.distribution, types.NUMBER, this.type),\n\r\r_randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n\r};\n\n\rthis.drag = {\n\r\r_value: utils.ensureTypedArg(options.drag.value, types.NUMBER, 0),\n\r\r_spread: utils.ensureTypedArg(options.drag.spread, types.NUMBER, 0),\n\r\r_randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n\r};\n\n\rthis.wiggle = {\n\r\r_value: utils.ensureTypedArg(options.wiggle.value, types.NUMBER, 0),\n\r\r_spread: utils.ensureTypedArg(options.wiggle.spread, types.NUMBER, 0)\n\r};\n\n\rthis.rotation = {\n\r\r_axis: utils.ensureInstanceOf(options.rotation.axis, THREE.Vector3, new THREE.Vector3(0.0, 1.0, 0.0)),\n\r\r_axisSpread: utils.ensureInstanceOf(options.rotation.axisSpread, THREE.Vector3, new THREE.Vector3()),\n\r\r_angle: utils.ensureTypedArg(options.rotation.angle, types.NUMBER, 0),\n\r\r_angleSpread: utils.ensureTypedArg(options.rotation.angleSpread, types.NUMBER, 0),\n\r\r_static: utils.ensureTypedArg(options.rotation.static, types.BOOLEAN, false),\n\r\r_center: utils.ensureInstanceOf(options.rotation.center, THREE.Vector3, this.position._value.clone()),\n\r\r_randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n\r};\n\n\n\rthis.maxAge = {\n\r\r_value: utils.ensureTypedArg(options.maxAge.value, types.NUMBER, 2),\n\r\r_spread: utils.ensureTypedArg(options.maxAge.spread, types.NUMBER, 0)\n\r};\n\n\n\n\r// The following properties can support either single values, or an array of values that change\n\r// the property over a particle's lifetime (value over lifetime).\n\rthis.color = {\n\r\r_value: utils.ensureArrayInstanceOf(options.color.value, THREE.Color, new THREE.Color()),\n\r\r_spread: utils.ensureArrayInstanceOf(options.color.spread, THREE.Vector3, new THREE.Vector3()),\n\r\r_randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n\r};\n\n\rthis.opacity = {\n\r\r_value: utils.ensureArrayTypedArg(options.opacity.value, types.NUMBER, 1),\n\r\r_spread: utils.ensureArrayTypedArg(options.opacity.spread, types.NUMBER, 0),\n\r\r_randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n\r};\n\n\rthis.size = {\n\r\r_value: utils.ensureArrayTypedArg(options.size.value, types.NUMBER, 1),\n\r\r_spread: utils.ensureArrayTypedArg(options.size.spread, types.NUMBER, 0),\n\r\r_randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n\r};\n\n\rthis.angle = {\n\r\r_value: utils.ensureArrayTypedArg(options.angle.value, types.NUMBER, 0),\n\r\r_spread: utils.ensureArrayTypedArg(options.angle.spread, types.NUMBER, 0),\n\r\r_randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n\r};\n\n\n\r// Assign renaining option values.\n\rthis.particleCount = utils.ensureTypedArg(options.particleCount, types.NUMBER, 100);\n\rthis.duration = utils.ensureTypedArg(options.duration, types.NUMBER, null);\n\rthis.isStatic = utils.ensureTypedArg(options.isStatic, types.BOOLEAN, false);\n\rthis.activeMultiplier = utils.ensureTypedArg(options.activeMultiplier, types.NUMBER, 1);\n\rthis.direction = utils.ensureTypedArg(options.direction, types.NUMBER, 1);\n\n\r// Whether this emitter is alive or not.\n\rthis.alive = utils.ensureTypedArg(options.alive, types.BOOLEAN, true);\n\n\n\r// The following properties are set internally and are not\n\r// user-controllable.\n\rthis.particlesPerSecond = 0;\n\n\r// The current particle index for which particles should\n\r// be marked as active on the next update cycle.\n\rthis.activationIndex = 0;\n\n\r// The offset in the typed arrays this emitter's\n\r// particle's values will start at\n\rthis.attributeOffset = 0;\n\n\r// The end of the range in the attribute buffers\n\rthis.attributeEnd = 0;\n\n\n\n\r// Holds the time the emitter has been alive for.\n\rthis.age = 0.0;\n\n\r// Holds the number of currently-alive particles\n\rthis.activeParticleCount = 0.0;\n\n\r// Holds a reference to this emitter's group once\n\r// it's added to one.\n\rthis.group = null;\n\n\r// Holds a reference to this emitter's group's attributes object\n\r// for easier access.\n\rthis.attributes = null;\n\n\r// Holds a reference to the params attribute's typed array\n\r// for quicker access.\n\rthis.paramsArray = null;\n\n\r// A set of flags to determine whether particular properties\n\r// should be re-randomised when a particle is reset.\n\r//\n\r// If a `randomise` property is given, this is preferred.\n\r// Otherwise, it looks at whether a spread value has been\n\r// given.\n\r//\n\r// It allows randomization to be turned off as desired. If\n\r// all randomization is turned off, then I'd expect a performance\n\r// boost as no attribute buffers (excluding the `params`)\n\r// would have to be re-passed to the GPU each frame (since nothing\n\r// except the `params` attribute would have changed).\n\rthis.resetFlags = {\n\r\r// params: utils.ensureTypedArg( options.maxAge.randomise, types.BOOLEAN, !!options.maxAge.spread ) ||\n\r\r//     utils.ensureTypedArg( options.wiggle.randomise, types.BOOLEAN, !!options.wiggle.spread ),\n\r\rposition: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false) ||\n\r\r\rutils.ensureTypedArg(options.radius.randomise, types.BOOLEAN, false),\n\r\rvelocity: utils.ensureTypedArg(options.velocity.randomise, types.BOOLEAN, false),\n\r\racceleration: utils.ensureTypedArg(options.acceleration.randomise, types.BOOLEAN, false) ||\n\r\r\rutils.ensureTypedArg(options.drag.randomise, types.BOOLEAN, false),\n\r\rrotation: utils.ensureTypedArg(options.rotation.randomise, types.BOOLEAN, false),\n\r\rrotationCenter: utils.ensureTypedArg(options.rotation.randomise, types.BOOLEAN, false),\n\r\rsize: utils.ensureTypedArg(options.size.randomise, types.BOOLEAN, false),\n\r\rcolor: utils.ensureTypedArg(options.color.randomise, types.BOOLEAN, false),\n\r\ropacity: utils.ensureTypedArg(options.opacity.randomise, types.BOOLEAN, false),\n\r\rangle: utils.ensureTypedArg(options.angle.randomise, types.BOOLEAN, false)\n\r};\n\n\rthis.updateFlags = {};\n\rthis.updateCounts = {};\n\n\r// A map to indicate which emitter parameters should update\n\r// which attribute.\n\rthis.updateMap = {\n\r\rmaxAge: 'params',\n\r\rposition: 'position',\n\r\rvelocity: 'velocity',\n\r\racceleration: 'acceleration',\n\r\rdrag: 'acceleration',\n\r\rwiggle: 'params',\n\r\rrotation: 'rotation',\n\r\rsize: 'size',\n\r\rcolor: 'color',\n\r\ropacity: 'opacity',\n\r\rangle: 'angle'\n\r};\n\n\rfor (var i in this.updateMap) {\n\r\rif (this.updateMap.hasOwnProperty(i)) {\n\r\r\rthis.updateCounts[this.updateMap[i]] = 0.0;\n\r\r\rthis.updateFlags[this.updateMap[i]] = false;\n\r\r\rthis._createGetterSetters(this[i], i);\n\r\r}\n\r}\n\n\rthis.bufferUpdateRanges = {};\n\rthis.attributeKeys = null;\n\rthis.attributeCount = 0;\n\n\n\r// Ensure that the value-over-lifetime property objects above\n\r// have value and spread properties that are of the same length.\n\r//\n\r// Also, for now, make sure they have a length of 3 (min/max arguments here).\n\rutils.ensureValueOverLifetimeCompliance(this.color, lifetimeLength, lifetimeLength);\n\rutils.ensureValueOverLifetimeCompliance(this.opacity, lifetimeLength, lifetimeLength);\n\rutils.ensureValueOverLifetimeCompliance(this.size, lifetimeLength, lifetimeLength);\n\rutils.ensureValueOverLifetimeCompliance(this.angle, lifetimeLength, lifetimeLength);\n};\n\nSPE.Emitter.constructor = SPE.Emitter;\n\nSPE.Emitter.prototype._createGetterSetters = function (propObj, propName) {\n\r'use strict';\n\n\rvar self = this;\n\n\rfor (var i in propObj) {\n\r\rif (propObj.hasOwnProperty(i)) {\n\n\r\r\rvar name = i.replace('_', '');\n\n\r\r\rObject.defineProperty(propObj, name, {\n\r\r\r\rget: (function (prop) {\n\r\r\r\r\rreturn function () {\n\r\r\r\r\r\rreturn this[prop];\n\r\r\r\r\r};\n\r\r\r\r}(i)),\n\n\r\r\r\rset: (function (prop) {\n\r\r\r\r\rreturn function (value) {\n\r\r\r\r\r\rvar mapName = self.updateMap[propName],\n\r\r\r\r\r\r\rprevValue = this[prop],\n\r\r\r\r\r\r\rlength = SPE.valueOverLifetimeLength;\n\n\r\r\r\r\r\rif (prop === '_rotationCenter') {\n\r\r\r\r\r\r\rself.updateFlags.rotationCenter = true;\n\r\r\r\r\r\r\rself.updateCounts.rotationCenter = 0.0;\n\r\r\r\r\r\r}\n\r\r\r\r\r\relse if (prop === '_randomise') {\n\r\r\r\r\r\r\rself.resetFlags[mapName] = value;\n\r\r\r\r\r\r}\n\r\r\r\r\r\relse {\n\r\r\r\r\r\r\rself.updateFlags[mapName] = true;\n\r\r\r\r\r\r\rself.updateCounts[mapName] = 0.0;\n\r\r\r\r\r\r}\n\n\r\r\r\r\r\rself.group._updateDefines();\n\n\r\r\r\r\r\rthis[prop] = value;\n\n\r\r\r\r\r\r// If the previous value was an array, then make\n\r\r\r\r\r\r// sure the provided value is interpolated correctly.\n\r\r\r\r\r\rif (Array.isArray(prevValue)) {\n\r\r\r\r\r\r\rSPE.utils.ensureValueOverLifetimeCompliance(self[propName], length, length);\n\r\r\r\r\r\r}\n\r\r\r\r\r};\n\r\r\r\r}(i))\n\r\r\r});\n\r\r}\n\r}\n};\n\nSPE.Emitter.prototype._setBufferUpdateRanges = function (keys) {\n\r'use strict';\n\n\rthis.attributeKeys = keys;\n\rthis.attributeCount = keys.length;\n\n\rfor (var i = this.attributeCount - 1; i >= 0; --i) {\n\r\rthis.bufferUpdateRanges[keys[i]] = {\n\r\r\rmin: Number.POSITIVE_INFINITY,\n\r\r\rmax: Number.NEGATIVE_INFINITY\n\r\r};\n\r}\n};\n\nSPE.Emitter.prototype._calculatePPSValue = function (groupMaxAge) {\n\r'use strict';\n\n\rvar particleCount = this.particleCount;\n\n\n\r// Calculate the `particlesPerSecond` value for this emitter. It's used\n\r// when determining which particles should die and which should live to\n\r// see another day. Or be born, for that matter. The 'God' property.\n\rif (this.duration) {\n\r\rthis.particlesPerSecond = particleCount / (groupMaxAge < this.duration ? groupMaxAge : this.duration);\n\r}\n\relse {\n\r\rthis.particlesPerSecond = particleCount / groupMaxAge;\n\r}\n};\n\nSPE.Emitter.prototype._setAttributeOffset = function (startIndex) {\n\rthis.attributeOffset = startIndex;\n\rthis.activationIndex = startIndex;\n\rthis.activationEnd = startIndex + this.particleCount;\n};\n\n\nSPE.Emitter.prototype._assignValue = function (prop, index) {\n\r'use strict';\n\n\rswitch (prop) {\n\r\rcase 'position':\n\r\r\rthis._assignPositionValue(index);\n\r\r\rbreak;\n\n\r\rcase 'velocity':\n\r\rcase 'acceleration':\n\r\r\rthis._assignForceValue(index, prop);\n\r\r\rbreak;\n\n\r\rcase 'size':\n\r\rcase 'opacity':\n\r\r\rthis._assignAbsLifetimeValue(index, prop);\n\r\r\rbreak;\n\n\r\rcase 'angle':\n\r\r\rthis._assignAngleValue(index);\n\r\r\rbreak;\n\n\r\rcase 'params':\n\r\r\rthis._assignParamsValue(index);\n\r\r\rbreak;\n\n\r\rcase 'rotation':\n\r\r\rthis._assignRotationValue(index);\n\r\r\rbreak;\n\n\r\rcase 'color':\n\r\r\rthis._assignColorValue(index);\n\r\r\rbreak;\n\r}\n};\n\nSPE.Emitter.prototype._assignPositionValue = function (index) {\n\r'use strict';\n\n\rvar distributions = SPE.distributions,\n\r\rutils = SPE.utils,\n\r\rprop = this.position,\n\r\rattr = this.attributes.position,\n\r\rvalue = prop._value,\n\r\rspread = prop._spread,\n\r\rdistribution = prop._distribution;\n\n\rswitch (distribution) {\n\r\rcase distributions.BOX:\n\r\r\rutils.randomVector3(attr, index, value, spread, prop._spreadClamp);\n\r\r\rbreak;\n\n\r\rcase distributions.SPHERE:\n\r\r\rutils.randomVector3OnSphere(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x, prop._distributionClamp || this.particleCount);\n\r\r\rbreak;\n\n\r\rcase distributions.DISC:\n\r\r\rutils.randomVector3OnDisc(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x);\n\r\r\rbreak;\n\n\r\rcase distributions.LINE:\n\r\r\rutils.randomVector3OnLine(attr, index, value, spread);\n\r\r\rbreak;\n\r}\n};\n\nSPE.Emitter.prototype._assignForceValue = function (index, attrName) {\n\r'use strict';\n\n\rvar distributions = SPE.distributions,\n\r\rutils = SPE.utils,\n\r\rprop = this[attrName],\n\r\rvalue = prop._value,\n\r\rspread = prop._spread,\n\r\rdistribution = prop._distribution,\n\r\rpos,\n\r\rpositionX,\n\r\rpositionY,\n\r\rpositionZ,\n\r\ri;\n\n\rswitch (distribution) {\n\r\rcase distributions.BOX:\n\r\r\rutils.randomVector3(this.attributes[attrName], index, value, spread);\n\r\r\rbreak;\n\n\r\rcase distributions.SPHERE:\n\r\r\rpos = this.attributes.position.typedArray.array;\n\r\r\ri = index * 3;\n\n\r\r\r// Ensure position values aren't zero, otherwise no force will be\n\r\r\r// applied.\n\r\r\r// positionX = utils.zeroToEpsilon( pos[ i ], true );\n\r\r\r// positionY = utils.zeroToEpsilon( pos[ i + 1 ], true );\n\r\r\r// positionZ = utils.zeroToEpsilon( pos[ i + 2 ], true );\n\r\r\rpositionX = pos[i];\n\r\r\rpositionY = pos[i + 1];\n\r\r\rpositionZ = pos[i + 2];\n\n\r\r\rutils.randomDirectionVector3OnSphere(\n\r\r\r\rthis.attributes[attrName], index,\n\r\r\r\rpositionX, positionY, positionZ,\n\r\r\r\rthis.position._value,\n\r\r\r\rprop._value.x,\n\r\r\r\rprop._spread.x\n\r\r\r);\n\r\r\rbreak;\n\n\r\rcase distributions.DISC:\n\r\r\rpos = this.attributes.position.typedArray.array;\n\r\r\ri = index * 3;\n\n\r\r\r// Ensure position values aren't zero, otherwise no force will be\n\r\r\r// applied.\n\r\r\r// positionX = utils.zeroToEpsilon( pos[ i ], true );\n\r\r\r// positionY = utils.zeroToEpsilon( pos[ i + 1 ], true );\n\r\r\r// positionZ = utils.zeroToEpsilon( pos[ i + 2 ], true );\n\r\r\rpositionX = pos[i];\n\r\r\rpositionY = pos[i + 1];\n\r\r\rpositionZ = pos[i + 2];\n\n\r\r\rutils.randomDirectionVector3OnDisc(\n\r\r\r\rthis.attributes[attrName], index,\n\r\r\r\rpositionX, positionY, positionZ,\n\r\r\r\rthis.position._value,\n\r\r\r\rprop._value.x,\n\r\r\r\rprop._spread.x\n\r\r\r);\n\r\r\rbreak;\n\n\r\rcase distributions.LINE:\n\r\r\rutils.randomVector3OnLine(this.attributes[attrName], index, value, spread);\n\r\r\rbreak;\n\r}\n\n\rif (attrName === 'acceleration') {\n\r\rvar drag = utils.clamp(utils.randomFloat(this.drag._value, this.drag._spread), 0, 1);\n\r\rthis.attributes.acceleration.typedArray.array[index * 4 + 3] = drag;\n\r}\n};\n\nSPE.Emitter.prototype._assignAbsLifetimeValue = function (index, propName) {\n\r'use strict';\n\n\rvar array = this.attributes[propName].typedArray,\n\r\rprop = this[propName],\n\r\rutils = SPE.utils,\n\r\rvalue;\n\n\rif (utils.arrayValuesAreEqual(prop._value) && utils.arrayValuesAreEqual(prop._spread)) {\n\r\rvalue = Math.abs(utils.randomFloat(prop._value[0], prop._spread[0]));\n\r\rarray.setVec4Components(index, value, value, value, value);\n\r}\n\relse {\n\r\rarray.setVec4Components(index,\n\r\r\rMath.abs(utils.randomFloat(prop._value[0], prop._spread[0])),\n\r\r\rMath.abs(utils.randomFloat(prop._value[1], prop._spread[1])),\n\r\r\rMath.abs(utils.randomFloat(prop._value[2], prop._spread[2])),\n\r\r\rMath.abs(utils.randomFloat(prop._value[3], prop._spread[3]))\n\r\r);\n\r}\n};\n\nSPE.Emitter.prototype._assignAngleValue = function (index) {\n\r'use strict';\n\n\rvar array = this.attributes.angle.typedArray,\n\r\rprop = this.angle,\n\r\rutils = SPE.utils,\n\r\rvalue;\n\n\rif (utils.arrayValuesAreEqual(prop._value) && utils.arrayValuesAreEqual(prop._spread)) {\n\r\rvalue = utils.randomFloat(prop._value[0], prop._spread[0]);\n\r\rarray.setVec4Components(index, value, value, value, value);\n\r}\n\relse {\n\r\rarray.setVec4Components(index,\n\r\r\rutils.randomFloat(prop._value[0], prop._spread[0]),\n\r\r\rutils.randomFloat(prop._value[1], prop._spread[1]),\n\r\r\rutils.randomFloat(prop._value[2], prop._spread[2]),\n\r\r\rutils.randomFloat(prop._value[3], prop._spread[3])\n\r\r);\n\r}\n};\n\nSPE.Emitter.prototype._assignParamsValue = function (index) {\n\r'use strict';\n\n\rthis.attributes.params.typedArray.setVec4Components(index,\n\r\rthis.isStatic ? 1 : 0,\n\r\r0.0,\n\r\rMath.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)),\n\r\rSPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread)\n\r);\n};\n\nSPE.Emitter.prototype._assignRotationValue = function (index) {\n\r'use strict';\n\n\rthis.attributes.rotation.typedArray.setVec3Components(index,\n\r\rSPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread),\n\r\rSPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread),\n\r\rthis.rotation._static ? 0 : 1\n\r);\n\n\rthis.attributes.rotationCenter.typedArray.setVec3(index, this.rotation._center);\n};\n\nSPE.Emitter.prototype._assignColorValue = function (index) {\n\r'use strict';\n\rSPE.utils.randomColorAsHex(this.attributes.color, index, this.color._value, this.color._spread);\n};\n\nSPE.Emitter.prototype._resetParticle = function (index) {\n\r'use strict';\n\n\rvar resetFlags = this.resetFlags,\n\r\rupdateFlags = this.updateFlags,\n\r\rupdateCounts = this.updateCounts,\n\r\rkeys = this.attributeKeys,\n\r\rkey,\n\r\rupdateFlag;\n\n\rfor (var i = this.attributeCount - 1; i >= 0; --i) {\n\r\rkey = keys[i];\n\r\rupdateFlag = updateFlags[key];\n\n\r\rif (resetFlags[key] === true || updateFlag === true) {\n\r\r\rthis._assignValue(key, index);\n\r\r\rthis._updateAttributeUpdateRange(key, index);\n\n\r\r\rif (updateFlag === true && updateCounts[key] === this.particleCount) {\n\r\r\r\rupdateFlags[key] = false;\n\r\r\r\rupdateCounts[key] = 0.0;\n\r\r\r}\n\r\r\relse if (updateFlag == true) {\n\r\r\r\r++updateCounts[key];\n\r\r\r}\n\r\r}\n\r}\n};\n\nSPE.Emitter.prototype._updateAttributeUpdateRange = function (attr, i) {\n\r'use strict';\n\n\rvar ranges = this.bufferUpdateRanges[attr];\n\n\rranges.min = Math.min(i, ranges.min);\n\rranges.max = Math.max(i, ranges.max);\n};\n\nSPE.Emitter.prototype._resetBufferRanges = function () {\n\r'use strict';\n\n\rvar ranges = this.bufferUpdateRanges,\n\r\rkeys = this.bufferUpdateKeys,\n\r\ri = this.bufferUpdateCount - 1,\n\r\rkey;\n\n\rfor (i; i >= 0; --i) {\n\r\rkey = keys[i];\n\r\rranges[key].min = Number.POSITIVE_INFINITY;\n\r\rranges[key].max = Number.NEGATIVE_INFINITY;\n\r}\n};\n\nSPE.Emitter.prototype._onRemove = function () {\n\r'use strict';\n\r// Reset any properties of the emitter that were set by\n\r// a group when it was added.\n\rthis.particlesPerSecond = 0;\n\rthis.attributeOffset = 0;\n\rthis.activationIndex = 0;\n\rthis.activeParticleCount = 0;\n\rthis.group = null;\n\rthis.attributes = null;\n\rthis.paramsArray = null;\n\rthis.age = 0.0;\n};\n\nSPE.Emitter.prototype._decrementParticleCount = function () {\n\r'use strict';\n\r--this.activeParticleCount;\n\n\r// TODO:\n\r//  - Trigger event if count === 0.\n};\n\nSPE.Emitter.prototype._incrementParticleCount = function () {\n\r'use strict';\n\r++this.activeParticleCount;\n\n\r// TODO:\n\r//  - Trigger event if count === this.particleCount.\n};\n\nSPE.Emitter.prototype._checkParticleAges = function (start, end, params, dt) {\n\r'use strict';\n\rfor (var i = end - 1, index, maxAge, age, alive; i >= start; --i) {\n\r\rindex = i * 4;\n\n\r\ralive = params[index];\n\n\r\rif (alive === 0.0) {\n\r\r\rcontinue;\n\r\r}\n\n\r\r// Increment age\n\r\rage = params[index + 1];\n\r\rmaxAge = params[index + 2];\n\n\r\rif (this.direction === 1) {\n\r\r\rage += dt;\n\n\r\r\rif (age >= maxAge) {\n\r\r\r\rage = 0.0;\n\r\r\r\ralive = 0.0;\n\r\r\r\rthis._decrementParticleCount();\n\r\r\r}\n\r\r}\n\r\relse {\n\r\r\rage -= dt;\n\n\r\r\rif (age <= 0.0) {\n\r\r\r\rage = maxAge;\n\r\r\r\ralive = 0.0;\n\r\r\r\rthis._decrementParticleCount();\n\r\r\r}\n\r\r}\n\n\r\rparams[index] = alive;\n\r\rparams[index + 1] = age;\n\n\r\rthis._updateAttributeUpdateRange('params', i);\n\r}\n};\n\nSPE.Emitter.prototype._activateParticles = function (activationStart, activationEnd, params, dtPerParticle) {\n\r'use strict';\n\rvar direction = this.direction;\n\n\rfor (var i = activationStart, index, dtValue; i < activationEnd; ++i) {\n\r\rindex = i * 4;\n\n\r\r// Don't re-activate particles that aren't dead yet.\n\r\r// if ( params[ index ] !== 0.0 && ( this.particleCount !== 1 || this.activeMultiplier !== 1 ) ) {\n\r\r//     continue;\n\r\r// }\n\n\r\rif (params[index] != 0.0 && this.particleCount !== 1) {\n\r\r\rcontinue;\n\r\r}\n\n\r\r// Increment the active particle count.\n\r\rthis._incrementParticleCount();\n\n\r\r// Mark the particle as alive.\n\r\rparams[index] = 1.0;\n\n\r\r// Reset the particle\n\r\rthis._resetParticle(i);\n\n\r\r// Move each particle being activated to\n\r\r// it's actual position in time.\n\r\r//\n\r\r// This stops particles being 'clumped' together\n\r\r// when frame rates are on the lower side of 60fps\n\r\r// or not constant (a very real possibility!)\n\r\rdtValue = dtPerParticle * (i - activationStart)\n\r\rparams[index + 1] = direction === -1 ? params[index + 2] - dtValue : dtValue;\n\n\r\rthis._updateAttributeUpdateRange('params', i);\n\r}\n};\n\n/**\n * Simulates one frame's worth of particles, updating particles\n * that are already alive, and marking ones that are currently dead\n * but should be alive as alive.\n *\n * If the emitter is marked as static, then this function will do nothing.\n *\n * @param  {Number} dt The number of seconds to simulate (deltaTime)\n */\nSPE.Emitter.prototype.tick = function (dt) {\n\r'use strict';\n\n\rif (this.isStatic) {\n\r\rreturn;\n\r}\n\n\rif (this.paramsArray === null) {\n\r\rthis.paramsArray = this.attributes.params.typedArray.array;\n\r}\n\n\rvar start = this.attributeOffset,\n\r\rend = start + this.particleCount,\n\r\rparams = this.paramsArray, // vec3( alive, age, maxAge, wiggle )\n\r\rppsDt = this.particlesPerSecond * this.activeMultiplier * dt,\n\r\ractivationIndex = this.activationIndex;\n\n\r// Reset the buffer update indices.\n\rthis._resetBufferRanges();\n\n\r// Increment age for those particles that are alive,\n\r// and kill off any particles whose age is over the limit.\n\rthis._checkParticleAges(start, end, params, dt);\n\n\r// If the emitter is dead, reset the age of the emitter to zero,\n\r// ready to go again if required\n\rif (this.alive === false) {\n\r\rthis.age = 0.0;\n\r\rreturn;\n\r}\n\n\r// If the emitter has a specified lifetime and we've exceeded it,\n\r// mark the emitter as dead.\n\rif (this.duration !== null && this.age > this.duration) {\n\r\rthis.alive = false;\n\r\rthis.age = 0.0;\n\r\rreturn;\n\r}\n\n\n\rvar activationStart = this.particleCount === 1 ? activationIndex : (activationIndex | 0),\n\r\ractivationEnd = Math.min(activationStart + ppsDt, this.activationEnd),\n\r\ractivationCount = activationEnd - this.activationIndex | 0,\n\r\rdtPerParticle = activationCount > 0 ? dt / activationCount : 0;\n\n\rthis._activateParticles(activationStart, activationEnd, params, dtPerParticle);\n\n\r// Move the activation window forward, soldier.\n\rthis.activationIndex += ppsDt;\n\n\rif (this.activationIndex > end) {\n\r\rthis.activationIndex = start;\n\r}\n\n\n\r// Increment the age of the emitter.\n\rthis.age += dt;\n};\n\n/**\n * Resets all the emitter's particles to their start positions\n * and marks the particles as dead if the `force` argument is\n * true.\n *\n * @param  {Boolean} [force=undefined] If true, all particles will be marked as dead instantly.\n * @return {Emitter}       This emitter instance.\n */\nSPE.Emitter.prototype.reset = function (force) {\n\r'use strict';\n\n\rthis.age = 0.0;\n\rthis.alive = false;\n\n\rif (force === true) {\n\r\rvar start = this.attributeOffset,\n\r\r\rend = start + this.particleCount,\n\r\r\rarray = this.paramsArray,\n\r\r\rattr = this.attributes.params.bufferAttribute;\n\n\r\rfor (var i = end - 1, index; i >= start; --i) {\n\r\r\rindex = i * 4;\n\n\r\r\rarray[index] = 0.0;\n\r\r\rarray[index + 1] = 0.0;\n\r\r}\n\n\r\rattr.updateRange.offset = 0;\n\r\rattr.updateRange.count = -1;\n\r\rattr.needsUpdate = true;\n\r}\n\n\rreturn this;\n};\n\n/**\n * Enables the emitter. If not already enabled, the emitter\n * will start emitting particles.\n *\n * @return {Emitter} This emitter instance.\n */\nSPE.Emitter.prototype.enable = function () {\n\r'use strict';\n\rthis.alive = true;\n\rreturn this;\n};\n\n/**\n * Disables th emitter, but does not instantly remove it's\n * particles fromt the scene. When called, the emitter will be\n * 'switched off' and just stop emitting. Any particle's alive will\n * be allowed to finish their lifecycle.\n *\n * @return {Emitter} This emitter instance.\n */\nSPE.Emitter.prototype.disable = function () {\n\r'use strict';\n\n\rthis.alive = false;\n\rreturn this;\n};\n\n/**\n * Remove this emitter from it's parent group (if it has been added to one).\n * Delgates to SPE.group.prototype.removeEmitter().\n *\n * When called, all particle's belonging to this emitter will be instantly\n * removed from the scene.\n *\n * @return {Emitter} This emitter instance.\n *\n * @see SPE.Group.prototype.removeEmitter\n */\nSPE.Emitter.prototype.remove = function () {\n\r'use strict';\n\rif (this.group !== null) {\n\r\rthis.group.removeEmitter(this);\n\r}\n\relse {\n\r\rconsole.error('Emitter does not belong to a group, cannot remove.');\n\r}\n\n\rreturn this;\n};\n"],"names":["SPE"],"mappings":"","file":"SPE.min.js"}